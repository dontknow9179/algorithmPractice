#### 求约数的个数

```java
import java.util.Scanner;

public class Main{
    public static void main(String[] args){
        Main m = new Main();
        m.output();
    }
    public void output(){
        Scanner sc = new Scanner(System.in);
        while(sc.hasNextInt()){
            int n = sc.nextInt();
            if(n == 0) break;
            int num;
            for(int i = 0; i < n; i++){
                num = sc.nextInt();
                System.out.println(calculate(num));
            }
        }    
        
    }
    public int calculate(int n){
        int count = 0;
        int i;
        for(i = 1; i * i < n; i++){
            if(n % i == 0) count += 2;                            
        }
        if(i * i == n) count++;
        return count;
    }
}
```

#### 质因数的个数

```java
import java.util.*;
public class Main{
    public static void main(String[] args){
        Main m = new Main();
        m.func();
    }
    public void func(){
        Scanner sc = new Scanner(System.in);
        int num, count;
        while(sc.hasNext()){
            count = 0;
            num = sc.nextInt();
            //这里有点难理解
            for(int i = 2; i <= Math.sqrt(num); ){
                if(num % i == 0){
                    count++;
                    num = num / i;
                }
                else{
                    i++;
                }
            }
            //这里有点难理解
            if(num > 1) count++;
            System.out.println(count);
        }
    }
}
```

#### 素数筛法

```java
import java.util.*;
public class Main{
    public static void main(String[] args){
        Main m = new Main();
        m.initial();
        m.func();
    }
    private void func(){
        Scanner sc = new Scanner(System.in);
        int n;
        while(sc.hasNext()){
            n = sc.nextInt();
            if(n > list.get(0))
                System.out.print(list.get(0));
            for(int i = 1; i < list.size(); i++){
                if(n <= list.get(i)) break;
                System.out.print(" "+list.get(i));
            }
            System.out.println();
        }
        sc.close();
    }
    private List<Integer> list = new ArrayList<>();
    private boolean[] flag = new boolean[10001];
    private void initial(){
        flag[0] = true;
        flag[1] = true;//true 合数
        for(int i = 2; i < 10001; i++){
            if(flag[i] == false){//false 质数
                if(i % 10 == 1){
                    list.add(i);
                }
                for(int j = i * i; j < 10001; j += i){
                    flag[j] = true;
                }
            }
            
        }
    }
}
```



#### 整数拆分成2的幂的和

```java
import java.util.*;

public class Main{
    public static void main(String[] args){
        Main m = new Main();
        m.func();
    }
    public void func(){
        Scanner sc = new Scanner(System.in);
        int num, pre = 0;
        int[] dp = new int[1000000];
        dp[0] = 1;
        while(sc.hasNext()){
            num = sc.nextInt();
            if(num <= pre){
                System.out.println(dp[num]);
            }
            else{
                for(int i = pre + 1; i <= num; i++){
                    if(i % 2 == 0){
                        dp[i] = (dp[i - 1] + dp[i / 2]) % 1000000000;
                    }
                    else{
                        dp[i] = dp[i - 1] % 1000000000;
                    }
                
                }
                pre = num;
                System.out.println(dp[num]);
            }
            
        }
    }
}
```



#### 成绩排序

```java
package newCoder;
import java.util.*;

public class Main {
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Main m = new Main();
        m.func();
	}
	private void func(){
		Scanner sc = new Scanner(System.in);
        while(sc.hasNext()){
            int n = sc.nextInt();
            Record[] nums = new Record[n];
            for(int i = 0; i < n; i++){
                nums[i] = new Record(sc.nextInt(),sc.nextInt());
            	//nums[i].number = sc.nextInt();
            	//nums[i].grade = sc.nextInt();
                //这样写会报错，原因是给null赋值
            }
            Arrays.sort(nums,new Comparator<Record>() {
				@Override
				public int compare(Record arg0, Record arg1) {
					// TODO Auto-generated method stub
					if(arg0.grade != arg1.grade) {
						return arg0.grade - arg1.grade;
					}					
					return arg0.number - arg1.number;
				}           	
            });
            for(int i = 0; i < n; i++){
            	System.out.print(nums[i].number);
            	System.out.print(" ");
                System.out.println(nums[i].grade);                
            }
        }
        sc.close();//!!!!!!
    }
}
class Record{
	public int number;
	public int grade;
	Record(){
		number = 0;
		grade = 0;
	}
	Record(int a, int b){
		number = a;
		grade = b;
	}
}
```

##### bug

+ 看上面的注释（另一种做法是用list，看下面）

```java
import java.util.*;
public class Main {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Main m = new Main();
        m.func();
	}
	private void func(){
        Scanner sc = new Scanner(System.in);
        while(sc.hasNext()){
            int n = sc.nextInt();
            List<Record> list = new ArrayList<>();
            for(int i = 0; i < n; i++){
                list.add(new Record(sc.nextInt(),sc.nextInt()));
            }
            Collections.sort(list,new Comparator<Record>() {

				@Override
				public int compare(Record arg0, Record arg1) {
					// TODO Auto-generated method stub
					if(arg0.grade != arg1.grade) {
						return arg0.grade - arg1.grade;
					}
					
					return arg0.number - arg1.number;
				}
            	
            });
            for(int i = 0; i < n; i++){
            	System.out.print(list.get(i).number);
            	System.out.print(" ");
                System.out.println(list.get(i).grade);
                
            }
        }
        sc.close();
    }
}
class Record{
	int number;
	int grade;
	Record(int a, int b){
		number = a;
		grade = b;
	}
}
```



#### 表达式求值

```java
import java.util.*;
public class Main{
    public static void main(String[] args){
        Main m = new Main();
        m.func();
    }
    private int index;
    private int priority(char c){
        if(c == '#') return 0;
        if(c == '$') return 1;
        if(c == '+' || c == '-') return 2;
        else return 3;
    }
    private double getNumber(String str){
        double number = 0;
        while(str.charAt(index) >= '0' && str.charAt(index) <= '9'){
            number *= 10;
            number += str.charAt(index) - '0';
            index++;//!!记得加1
        }
        return number;
    }
    private double calculate(double left, double right, char c){
        double result = 0;
        if(c == '+') result = left + right;
        else if(c == '-') result = left - right;
        else if(c == '*') result = left * right;
        else if(c == '/') result = left / right;
        return result;
    }
    private void func(){
        Scanner sc = new Scanner(System.in);
        while(sc.hasNext()){
            String str = sc.nextLine();
            if(str.charAt(0) == '0' && str.length() == 1){
                break;
            }
            str = str + "$";
            index = 0;
            double left, right, result;
            char operator;
            Stack<Double> stackd = new Stack<>();
            Stack<Character> stackc = new Stack<>();
            stackc.push('#');
            while(index < str.length()){
                if(str.charAt(index) == ' '){
                    index++;
                    continue;
                }
                else if(str.charAt(index) >= '0' && str.charAt(index) <= '9'){
                    stackd.push(getNumber(str));
                }
                else{
                    if(priority(str.charAt(index)) > priority(stackc.peek())){
                        stackc.push(str.charAt(index));
                        index++;
                    }
                    else{
                        operator = stackc.pop();
                        right = stackd.pop();
                        left = stackd.pop();
                        result = calculate(left, right, operator);
                        stackd.push(result);
                    }
                }
            }
            System.out.format("%.2f%n",stackd.pop());
        }
    }
}
```

##### bug

+ format输出的时候忘记%n了
+ 换变量名的时候漏了一个没换
+ 数组越界，在getNumber的时候index可能超出范围
+ 初始化的时候忘记push，漏掉‘#’了
+ length()==1写成了==0
+ static要写在void前面



#### 最大公约数（可用来判断两个数能否互质）

```java
import java.util.*;
public class Main{
    public static void main(String[] args){
        Main m = new Main();
        m.func();
    }
    private void func(){
        Scanner sc = new Scanner(System.in);
        int m, n, res;
        while(sc.hasNext()){
            m = sc.nextInt();
            n = sc.nextInt();
            res = GCD(m, n);
            System.out.println(res);
        }
    }
    private int GCD(int m, int n){
        int temp;
        if(n > m){
            temp = n;
            n = m;
            m = temp;
        }
        if(n == 0){
            return m;
        }
        else{
            return GCD(n, m % n);
        }
    }
}
```

#### 最小公倍数

两个数的乘积除以最大公约数即可

#### 素数

只需测试到sqrt(n)

```java
import java.util.*;

public class Main{
    public static void main(String[] args){
        Main m = new Main();
        m.func();
    }
    private void func(){
        Scanner sc = new Scanner(System.in);
        int n;
        while(sc.hasNext()){
            n = sc.nextInt();
            if(n < 2){
                System.out.println("no");
                continue;
            }
            int i;
            for(i = 2; i <= Math.sqrt(n); i++){
                if(n % i == 0){
                    System.out.println("no");
                    break;
                }
            }
            if(i > Math.sqrt(n)){
                System.out.println("yes");
            }//这里的if语句一开始忘记加了，而且要用>不能用>=
            
        }
    }
}

```



#### 快速幂

```java
int fast(int a, int b, int mod){
	int answer = 1;
    while(b != 0){         //不断将b转换为二进制数
        if(b % 2 == 1){    //若当前位为1，累乘a的2^k次幂
            answer *= a;
            answer %= mod;
        }
        b /= 2;
        a *= a;
        a %= mod;
    }
    return answer;
}
```



#### 矩阵快速幂

```java
import java.util.*;
public class Main{
    public static void main(String[] args){
        Main m = new Main();
        m.func();
    }
    private void multiply(int[][] nums, int size, int k){
        int[][] ans = new int[size][size];
        for(int i = 0; i < size; i++){
            for(int j = 0; j < size; j++){
                if(i == j)
                    ans[i][j] = 1;
                else
                    ans[i][j] = 0;
            }
        }
        while(k != 0){
            if(k % 2 == 1){
                mul(ans, nums, size);
            }
            k /= 2;
            mulself(nums, size);
        }
        //nums = ans
        for(int i = 0; i < size; i++){
            for(int j = 0; j < size; j++){
                nums[i][j] = ans[i][j];
            }
        }
    }
    //ans *= nums
    private void mul(int[][] ans, int[][] nums, int size){
        int[][] temp = new int[size][size];
        for(int i = 0; i < size; i++){
            for(int j = 0; j < size; j++){
                temp[i][j] = ans[i][j];
            }
        }
        for(int i = 0; i < size; i++){
            for(int j = 0; j < size; j++){
                ans[i][j] = 0;
                for(int k = 0; k < size; k++){
                    ans[i][j] += temp[i][k] * nums[k][j];
                }
            }
        }
    }
    //nums *= nums
    private void mulself(int[][] nums, int size){
        int[][] temp = new int[size][size];
        for(int i = 0; i < size; i++){
            for(int j = 0; j < size; j++){
                temp[i][j] = nums[i][j];
            }
        }
        for(int i = 0; i < size; i++){
            for(int j = 0; j < size; j++){
                nums[i][j] = 0;
                for(int k = 0; k < size; k++){
                    nums[i][j] += temp[i][k] * temp[k][j];
                }
            }
        }
    }
    private void func(){
        Scanner sc = new Scanner(System.in);
        
        int size, k;
        while(sc.hasNext()){
            size = sc.nextInt();
            k = sc.nextInt();
            int[][] nums = new int[size][size];
            for(int i = 0; i < size; i++){
                for(int j = 0; j < size; j++){
                    nums[i][j] = sc.nextInt();
                }
            }
            multiply(nums, size, k);
            for(int i = 0; i < size; i++){
                for(int j = 0; j < size; j++){
                    System.out.print(nums[i][j]);
                    if(j < size - 1){
                        System.out.print(" ");
                    }
                    else{
                        System.out.println();
                    }
                }
            }
            
        }
    }
}
```

#### 2的幂次（分治）

```java
import java.util.*;
public class Main{
    public static void main(String[] args){
        Main m = new Main();
        m.func();
    }
    private void func(){
        Scanner sc = new Scanner(System.in);
        int n;
        while(sc.hasNext()){
            n = sc.nextInt();
            System.out.println(calculate(n).toString());
        }
    }
    private StringBuilder calculate(int n){     
        List<Integer> list = new ArrayList<>();
        int i = 0;
        while(n != 0){
            if(n % 2 == 1){
                list.add(i);
            }
            n /= 2;
            i++;
        }
        StringBuilder res = new StringBuilder();
        for(int j = list.size() - 1; j >= 0; j--){
            if(list.get(j) == 1){
                res.append("2");
            }
            else if(list.get(j) == 0){
                res.append("2(0)");
            }
            else{
                res.append("2(");
                res.append(calculate(list.get(j)));
                res.append(")");
            }            
            if(j != 0){
                res.append("+");
            }
        }
        return res;
    }
}
```

#### 玛雅人的密码（BFS)

```java
import java.util.*;
public class Main{
    public static void main(String[] args){
        Main m = new Main();
        m.func();
    }
    private void func(){
        Scanner sc = new Scanner(System.in);
        while(sc.hasNext()){
            int n = sc.nextInt();
            String str = sc.next();
            if(n < 4){
                System.out.println("-1");
                continue;
            }
            if(str.indexOf("2012") != -1){
                System.out.println("0");
                continue;
            }
            System.out.println(bfs(str, n));
        }
    }
    private int bfs(String str, int n){
        Queue<String> queue = new LinkedList<>();
        List<String> list = new ArrayList<>();
        queue.add(str);
        list.add(str);
        int count = 1;
        while(!queue.isEmpty()){
            int size = queue.size();
            while(size > 0){
                String current = queue.poll();               
                for(int i = 0; i < n - 1; i++){
                    char[] chars = current.toCharArray();
                    char temp = chars[i];
                    chars[i] = chars[i + 1];
                    chars[i + 1] = temp;
                    String next = new String(chars);
                    if(next.indexOf("2012") != -1){
                        return count;
                    }
                    else if(!list.contains(next)){
                        queue.add(next);
                        list.add(next);
                    }
                }
                size--;
            }
            count++;
        }
        return -1;
    }
}
```

#### 神奇的口袋（DFS）

```java
import java.util.*;
public class Main{
    public static void main(String[] args){
        Main m = new Main();
        m.func();
    }
    private int[] nums;
    private int count;
    private void func(){
        Scanner sc = new Scanner(System.in);
        while(sc.hasNext()){
            int n = sc.nextInt();
            nums = new int[n];
            count = 0;
            for(int i = 0; i < n; i++){
                nums[i] = sc.nextInt();
            }
            dfs(0, 0);
            System.out.println(count);
        }
    }
    private void dfs(int sum, int position){
        if(sum == 40){
            count++;
            return;
        }
        for(int i = position; i < nums.length; i++){
            if(sum + nums[i] <= 40){
                dfs(sum + nums[i], i + 1);
            }
        }
        return;
    }
}
```

#### 八皇后（DFS, backtracking)

```java
import java.util.*;
public class Main{
    public static void main(String[] args){
        Main m = new Main();
        m.func();
    }
    private List<String> list = new ArrayList<>();
    private boolean[] col = new boolean[8];
    private boolean[] degree45 = new boolean[15];
    private boolean[] degree135 = new boolean[15];
    private void func(){
        Scanner sc = new Scanner(System.in);
        dfs(0, new StringBuilder());
        while(sc.hasNext()){
            int x = sc.nextInt();
            System.out.println(list.get(x - 1));
        }
    }
    private void dfs(int row, StringBuilder prefix){
        if(row == 8){
            if(prefix.length() == 8){
                list.add(prefix.toString());            
            }
            return;
        }       
        for(int i = 0; i < 8; i++){
            if(col[i] || degree45[row + i] || degree135[row - i + 7]){
                continue;
            }
            col[i] = true;
            degree45[row + i] = true;
            degree135[row - i + 7] = true;
            prefix.append(Integer.toString(i + 1));
            dfs(row + 1, prefix);
            col[i] = false;
            degree45[row + i] = false;
            degree135[row - i + 7] = false;
            prefix.deleteCharAt(prefix.length() - 1);
        }
        return;
    }
}
```

#### 前序遍历结果构建二叉树然后中序遍历

 ABC##DE#G##F### 其中“#”表示的是空格，空格字符代表空树。

```java
import java.util.*;
public class Main{
    public static void main(String[] args){
        Main m = new Main();
        m.func();
    }
    private int position;
    private void func(){
        Scanner sc = new Scanner(System.in);
        while(sc.hasNext()){
            String str = sc.next();
            position = 0;
            TreeNode root = buildTree(str);
            inorder(root);
            System.out.println();
        }
    }
    private void inorder(TreeNode root){
        if(root == null){
            return;
        }
        inorder(root.left);
        System.out.print(root.value + " ");
        inorder(root.right);
    }
    private TreeNode buildTree(String str){
        char c = str.charAt(position);
        position++;
        if(c == '#'){
            return null;
        }
        TreeNode root = new TreeNode(c);
        root.left = buildTree(str);
        root.right = buildTree(str);
        return root;
    }
}

class TreeNode{
    char value;
    TreeNode left;
    TreeNode right;
    TreeNode(char val){
        value = val;
    }
}
```

#### 先序和中序遍历建立二叉树

```java
import java.util.*;
public class Main{
    public static void main(String[] args){
        Main m = new Main();
        m.func();
    }
    private void func(){
        Scanner sc = new Scanner(System.in);
        while(sc.hasNext()){
            String preorder = sc.next();
            String inorder = sc.next();
            TreeNode root = build(preorder, inorder);
            postorder(root);
            System.out.println();
        }
    }
    private void postorder(TreeNode root){
        if(root == null){
            return;
        }
        postorder(root.left);
        postorder(root.right);
        System.out.print(root.value);
    }
    private TreeNode build(String preorder, String inorder){
        if(preorder.length() == 0){
            return null;
        }
        TreeNode root = new TreeNode(preorder.charAt(0));
        int position = inorder.indexOf(preorder.charAt(0));
        root.left = build(preorder.substring(1, 1 + position), inorder.substring(0, position));
        root.right = build(preorder.substring(1 + position), inorder.substring(position + 1));
        return root;
    }
}
class TreeNode{
    char value;
    TreeNode left;
    TreeNode right;
    TreeNode(char c){
        value = c;
    }
}
```

#### 二叉排序树，求父节点

```java
import java.util.*;
public class Main{
    public static void main(String[] args){
        Main m = new Main();
        m.func();
    }
    private void func(){
        Scanner sc = new Scanner(System.in);
        while(sc.hasNext()){
            int n = sc.nextInt();
            int val = sc.nextInt();
            TreeNode root = new TreeNode(val);
            n--;
            System.out.println(-1);
            while(n != 0){
                int x = sc.nextInt();
                insert(root, x);
                n--;
            }
        }
    }
    private void insert(TreeNode root, int x){
        if(x < root.value){
            if(root.left == null){
                TreeNode node = new TreeNode(x);
                root.left = node;
                System.out.println(root.value);
            }
            else{
                insert(root.left, x);
            }
        }
        else{
            if(root.right == null){
                TreeNode node = new TreeNode(x);
                root.right = node;
                System.out.println(root.value);
            }
            else{
                insert(root.right, x);
            }
        }
    }
}
class TreeNode{
    int value;
    TreeNode left;
    TreeNode right;
    TreeNode(int val){
        value = val;
    }
}
```

#### 优先级队列（复数）

```java
import java.util.*;
public class Main{
    public static void main(String[] args){
        Main m = new Main();
        m.func();
    }
    private void func(){
        Scanner sc = new Scanner(System.in);
        Comparator<Number> compare = new Comparator<Number>(){
            public int compare(Number o1, Number o2){
                int res = o1.real * o1.real + o1.imag * o1.imag - o2.real * o2.real - o2.imag * o2.imag;
                return -res;
            }
        };
        while(sc.hasNext()){
            int n = sc.nextInt();
            Queue<Number> queue = new PriorityQueue<Number>(compare);
            while(n > 0){
                String str = sc.next();
                if(str.equals("Pop")){
                    if(queue.isEmpty()){
                        System.out.println("empty");
                    }
                    else{
                        Number number = queue.poll();
                        System.out.println(number.real + "+i" + number.imag);
                        System.out.println("SIZE = " + queue.size());
                    }
                }
                else{
                    String str1 = sc.next();
                    
                    Number cur = new Number(Integer.parseInt(str1.substring(0,str1.indexOf('+'))),
                                                            Integer.parseInt(str1.substring(str1.indexOf('i')+1)));
                    
                    queue.add(cur);
                    System.out.println("SIZE = " + queue.size());
                }
                n--;
            }
        }
        sc.close();
    }
}
class Number{
    int real;
    int imag;
    Number(int r, int i){
        real = r;
        imag = i;
    }
}
```

##### bug

+ a+bi中a和b不一定是个位数，因为这个原因卡了很久很久

#### 查找学生信息（HashMap)

```java
import java.util.*;
public class Main{
    public static void main(String[] args){
        Main m = new Main();
        m.func();
    }
    private void func(){
        Scanner sc = new Scanner(System.in);
        while(sc.hasNext()){
            int n = sc.nextInt();
            HashMap<String, String> map = new HashMap<>();
            while(n > 0){               
                String key = sc.next();
                String value = sc.nextLine();                
                map.put(key, value);
                n--;
            }
            int m = sc.nextInt();
            while(m > 0){
                String query = sc.next();
                if(map.containsKey(query)){
                    System.out.println(query + map.get(query));
                }
                else{
                    System.out.println("No Answer!");
                }
                
                m--;
            }
        }
        sc.close();
    }
}
```

##### bug

+ `sc.nextLine()`的用法要注意

#### 魔咒词典

```java
import java.util.*;
public class Main{
    public static void main(String[] args){
        Main m = new Main();
        m.func();
    }
    private void func(){
        Scanner sc = new Scanner(System.in);
        HashMap<String, String> map = new HashMap<>();
        while(sc.hasNext()){
            while(true){
                String str = sc.nextLine();
                if(str.equals("@END@")){
                    break;
                }
                int index = str.indexOf("]");
                String key = str.substring(0, index + 1);
                String value = str.substring(index + 2);
                map.put(key, value);
                map.put(value, key);
            }
            int n = sc.nextInt();
            sc.nextLine();
            while(n > 0){
                String query = sc.nextLine();
                String res = map.getOrDefault(query, "what?");
                if(res.charAt(0) == '['){
                    res = res.substring(1, res.length() - 1);
                }
                System.out.println(res);
                n--;
            }            
        }
    }
}
```

##### bug

+ 要用中括号来分割key和value，不能用空格

+ `map.put(value, key)`可以不用两个map

  

#### 畅通工程（并查集）

```java
import java.util.*;
public class Main{
    public static void main(String[] args){
        Main m = new Main();
        m.func();
    }
    private int[] father = new int[1001];
    private int[] height = new int[1001];
    private int find(int x){
        if(x != father[x]){
            father[x] = find(father[x]);
        }
        return father[x];
    }
    private void union(int a, int b){
        a = find(a);
        b = find(b);
        if(a != b){
            if(height[a] > height[b]){
                father[b] = a;
            }
            else if(height[b] > height[a]){
                father[a] = b;
            }
            else{
                father[b] = a;
                height[a]++;
            }
        }
        return;
    }
    private void func(){
        Scanner sc = new Scanner(System.in);
        int n, m;
        int a, b;
        int ans;
        while(sc.hasNext()){
            n = sc.nextInt();
            if(n == 0)
                break;
            m = sc.nextInt();
            for(int i = 1; i <= n; i++){
                father[i] = i;
                height[i] = 0;
            }
            for(int i = 0; i < m; i++){
                a = sc.nextInt();
                b = sc.nextInt();
                union(a, b);
            }
            ans = 0;
            for(int i = 1; i <= n; i++){
                if(father[i] == i){
                    ans++;
                }
            }
            System.out.println(ans - 1);
        }
    }
}
```

#### 判断是不是树（并查集）

```java
import java.util.*;
public class Main{
    public static void main(String[] args){
        Main m = new Main();
        m.func();
    }
    private int[] father = new int[10001];
    private boolean[] visited = new boolean[10001];
    private int[] height = new int[10001];
    private int[] indegree = new int[10001];
    
    private void initial(){
        for(int i = 1; i < 10001; i++){
            father[i] = i;
            indegree[i] = 0;
            height[i] = 0;
            visited[i] = false;
        }
    }
    private int find(int x){
        if(father[x] != x){
            father[x] = find(father[x]);
        }
        return father[x];
    }
    private void union(int x, int y){
        x = find(x);
        y = find(y);
        if(x != y){
            if(height[x] < height[y]){
                father[x] = y;
            }
            else if(height[x] > height[y]){
                father[y] = x;
            }
            else{
                father[y] = x;
                height[x]++;
            }
        }
    }
    private boolean isTree(){
        int count = 0;
        int root = 0;
        boolean flag = true;
        for(int i = 1; i < 10001; i++){
            if(visited[i]){
                if(father[i] == i){
                    count++;
                }
                if(indegree[i] == 0){
                    root++;
                }
                if(indegree[i] > 1){
                    flag = false;
                }
            }
        }
        if(root != 1 || count != 1){
            flag = false;
        }
        if(root == 0 && count == 0){
            flag = true;
        }
        return flag;
    }
    private void func(){
        Scanner sc = new Scanner(System.in);
        int x, y;
        int k = 0;
        initial();
        while(sc.hasNext()){
            x = sc.nextInt();
            y = sc.nextInt();
            if(x == -1 && y == -1){
                break;
            }
            if(x == 0 && y == 0){
                k++;
                if(isTree()){
                    System.out.println("Case " + k + " is a tree.");
                }
                else{
                    System.out.println("Case " + k + " is not a tree.");
                }
                initial();
            }
            else{
                visited[x] = true;
                visited[y] = true;
                union(x, y);
                indegree[y]++;
            }
        }
    }
}
```

##### bug

+ 当x==0&&y==0时判断是否为树，然后initial下一棵树
+ 第一棵树要在最前面initial
+ count==0 && root==0 空集也是树
+ 其余情况必须是count==1 && root==1, indegree不能大于1
+ visited数组很有用，因为不知道每一次的范围
+ union之后记得修改height



#### 还是畅通工程

```java
import java.util.*;
public class Main{
    public static void main(String[] args){
        Main m = new Main();
        m.func();
    }
    private int[] father = new int[100];
    private int[] height = new int[100];
    private void initial(int n){
        for(int i = 1; i <= n; i++){
            father[i] = i;
            height[i] = 0;
        }
        
    }
    private int find(int x){
        if(x != father[x]){
            father[x] = find(father[x]);
        }
        return father[x];
    }
    private void union(int x, int y){
        //x = find(x);
        //y = find(y);
        if(x != y){
            if(height[x] < height[y]){
                father[x] = y;
            }
            else if(height[x] > height[y]){
                father[y] = x;
            }
            else{
                father[y] = x;
                height[x]++;
            }
        }
    }
    private void func(){
        Scanner sc = new Scanner(System.in);
        int n;
        int edgenumber;
        int from, to;
        int ans;
        while(sc.hasNext()){
            n = sc.nextInt();
            if(n == 0){
                break;
            }
            initial(n);
            ans = 0;
            edgenumber = n * (n - 1) / 2;
            Edge[] edges = new Edge[edgenumber];
            for(int i = 0; i < edgenumber; i++){
                edges[i] = new Edge(sc.nextInt(),sc.nextInt(),sc.nextInt());
                int flag = sc.nextInt();
                if(flag == 1){
                    edges[i].length = 0;
                }
                    
            }
            Arrays.sort(edges, new Comparator<Edge>(){
                public int compare(Edge o1, Edge o2){
                    return o1.length - o2.length;
                }
            });
            for(int i = 0; i < edgenumber; i++){
                from = edges[i].from;
                to = edges[i].to;
                //System.out.println(from + " " + to);
                from = find(from);
                to = find(to);
                //System.out.println(from + " " + to);
                if(from != to){
                    union(from, to);
                    ans += edges[i].length;
                }
            }
            System.out.println(ans);
        }
    }
}
class Edge{
    int length;
    int from;
    int to;
    Edge(int f, int t, int l){
        from = f;
        to = t;
        length = l;
    }
}
```

##### bug

+ initial函数中i应该小于等于n



#### Dijkstra(hard)

```java
import java.util.*;
public class Main{
    public static void main(String[] args){
        Main m = new Main();
        m.func();
    }
    private int[] distance;
    private int[] cost;
    private ArrayList<ArrayList<Edge>> graph;
    private void func(){
        Scanner sc = new Scanner(System.in);
        int n, m;
        while(sc.hasNext()){
            n = sc.nextInt();
            m = sc.nextInt();
            if(n == 0 && m == 0){
                break;
            }
            distance = new int[n + 1];
            cost = new int[n + 1];
            for(int i = 0; i < n + 1; i++) {
            	distance[i] = Integer.MAX_VALUE;
            	cost[i] = Integer.MAX_VALUE;
            }
            graph = new ArrayList<>(n + 1);
            for(int i = 0; i <= n; i++) {
            	ArrayList<Edge> ei = new ArrayList<>();
            	graph.add(ei);
            }
            int from, to, length, price;
            for(int i = 0; i < m; i++) {
            	from = sc.nextInt();
            	to = sc.nextInt();
            	length = sc.nextInt();
            	price = sc.nextInt();
            	graph.get(from).add(new Edge(to, length, price));
            	graph.get(to).add(new Edge(from, length, price));
            }
            int s, t;
            s = sc.nextInt();
            t = sc.nextInt();
            dijkstra(s);
            System.out.println(distance[t] + " " + cost[t]);
        }
        sc.close();
    }
    
    private void dijkstra(int s) {
    	Queue<Point> queue = new PriorityQueue<Point>(new Comparator<Point>() {
    		public int compare(Point o1, Point o2) {
    			return o1.distance - o2.distance;
    		}
    	});
    	cost[s] = 0;
    	distance[s] = 0;
    	queue.add(new Point(s, 0));
    	while(!queue.isEmpty()) {
    		Point p = queue.poll();
    		int num = p.number;
            if(distance[num] < p.distance) continue; // 这个point是无效的，跳过
    		for(int i = 0; i < graph.get(num).size(); i++) {
    			int v = graph.get(num).get(i).to;
    			int l = graph.get(num).get(i).length;
    			int c = graph.get(num).get(i).price;
    			if(distance[v] > distance[num] + l || (distance[v] == distance[num] + l && cost[v] > cost[num] + c)) {
    				distance[v] = distance[num] + l;
    				cost[v] = cost[num] + c;
    				queue.add(new Point(v, distance[v]));
    			}
    		}
    	}
    }
}
class Point{
    int number;
    int distance;
    Point(int a, int b){
    	number = a;
    	distance = b;
    }
}
class Edge{
    int to;
    int length;
    int price;
    Edge(int a, int b, int c){
        to = a;
        length = b;
        price = c;
    }
}
```

##### 语法

+ ```java
  graph = new ArrayList<>(n + 1);
              for(int i = 0; i <= n; i++) {
              	ArrayList<Edge> ei = new ArrayList<>();
              	graph.add(ei);
              }
  ArrayList<Edge>[] graph;
    graph = new ArrayList[n + 1];
                for(int i = 0; i <= n; i++) {
                	graph[i] = new ArrayList<>();
                }
  ```



#### 拓扑排序

  ```java
import java.util.*;

public class Main {
	public static void main(String[] args) {
		Main m = new Main();
		m.func();
	}
	private void func() {
		Scanner sc = new Scanner(System.in);
		int n, m;
		int from, to;
		while(sc.hasNext()) {
			n = sc.nextInt();
			m = sc.nextInt();
			int[] indegree = new int[n + 1];
			ArrayList<ArrayList<Integer>> graph = new ArrayList<>(n + 1);
			for(int i = 0; i < n + 1; i++) {
				graph.add(new ArrayList<Integer>());
			}
			while(m > 0) {
				from = sc.nextInt();
				to = sc.nextInt();
				graph.get(from).add(to);
				indegree[to]++;
				m--;
			}
			Queue<Integer> queue = new PriorityQueue<Integer>();
			for(int i = 1; i < n + 1; i++) {
				if(indegree[i] == 0) {
					queue.add(i);
				}
			}
			boolean flag = false;
			while(!queue.isEmpty()) {
				int num = queue.poll();
				if(flag) {
					System.out.print(" ");
				}
				System.out.print(num);
				flag = true;
				for(int i = 0; i < graph.get(num).size(); i++) {
					int v = graph.get(num).get(i);
					indegree[v]--;
					if(indegree[v] == 0) {
						queue.add(v);
					}
				}
			}
			
		}
	}
}
  ```



#### 最少邮票数（01背包）

```java
import java.util.*;
public class Main{
    public static void main(String[] args){
        Main m = new Main();
        m.func();
    }
    private void func(){
        Scanner sc = new Scanner(System.in);
        int m, n;
        while(sc.hasNext()){
            m = sc.nextInt();
            n = sc.nextInt();
            int[] dp = new int[m + 1];
            int[] weight = new int[n];
            for(int i = 0; i < n; i++){
                weight[i] = sc.nextInt();
            }
            for(int i = 1; i < m + 1; i++){
                dp[i] = 100;
            }
            for(int i = 0; i < n; i++){
                for(int j = m; j >= weight[i]; j--){
                    dp[j] = Math.min(dp[j], dp[j - weight[i]] + 1);
                }
            }
            if(dp[m] > 20)
                dp[m] = 0;
            System.out.println(dp[m]);
        }
    }
}
```

##### 注意

除了dp[0]=0以外，初始化为一个很大的数而不是0，状态转移方程也不一样



#### 谁是你的潜在朋友（不需要map，解决映射问题）

```java
import java.util.*;
public class Main{
    public static void main(String[] args){
        Main m = new Main();
        m.func();
    }
    private void func(){
        Scanner sc = new Scanner(System.in);
        int n, m;
        while(sc.hasNext()){
            n = sc.nextInt();
            m = sc.nextInt();
            int[] student = new int[n + 1];
            int[] book = new int[m + 1];
            for(int i = 1; i <= n; i++){
                student[i] = sc.nextInt();
                book[student[i]]++;
            }
            int num;
            for(int i = 1; i <= n; i++){
                num = book[student[i]] - 1;
                if(num == 0){
                    System.out.println("BeiJu");
                }
                else{
                    System.out.println(num);
                }
            }
        }
    }
}
```

#### 密码翻译

```java
import java.util.*;
public class Main{
    public static void main(String[] args){
        Main m = new Main();
        m.func();
    }
    private void func(){
        Scanner sc = new Scanner(System.in);
        while(sc.hasNext()){
            String str = sc.nextLine();
            StringBuilder strb = new StringBuilder("");
            for(int i = 0; i < str.length(); i++){
                if(str.charAt(i) == 'Z'){
                    strb.append('A');
                }
                else if(str.charAt(i) == 'z'){
                    strb.append('a');
                }
                else if((str.charAt(i) < 'Z' && str.charAt(i) >= 'A')||(str.charAt(i) < 'z' && str.charAt(i) >= 'a')){
                    strb.append((char)(str.charAt(i) + 1));
                }
                else{
                    strb.append(str.charAt(i));
                }
            }
            System.out.println(strb);
        }
    }
}
```

##### bug

+ str.charAt(i)+1之后是int型，要在前面加(char)强制类型转换

#### 日志排序（对java及其不友好

```java
import java.util.*;
public class Main{
    public static void main(String[] args){
        Main m = new Main();
        m.func();
    }
    private void func(){
        Scanner sc = new Scanner(System.in);
        List<String> list = new ArrayList<>();
        while(sc.hasNextLine()){
            String str = sc.nextLine();
            if(str.trim().isEmpty()) 
                break;
            list.add(str);
        }
        Collections.sort(list, new Comparator<String>(){
            public int compare(String o1, String o2){
                String[] str1 = o1.split("\\s+");
                String[] str2 = o2.split("\\s+");
                double time1 = Double.parseDouble(str1[3].substring(0,str1[3].length() - 3));
                double time2 = Double.parseDouble(str2[3].substring(0,str2[3].length() - 3));
 
                if(Math.abs(time1 - time2) > 0.0001){
                    if(time1 - time2 > 0){
                        return 1;
                    }
                    return -1;
                }
                else if(!str1[1].equals(str2[1])){
                    return str1[1].compareTo(str2[1]);
                }
                return str1[2].compareTo(str2[2]);
            }
        });
        for(int i = 0; i < list.size(); i++){
            System.out.println(list.get(i));
        }
    }
}
```

##### bug

+ double型数据的比较和int不一样
+ string型的比较也不能用减法
+ 不定长的数字比较不能用string来比较，要用数字
+ 输入为空行时停止，要用`sc.hasNextLine()`和`String str = sc.nextLine();`
  `if(str.trim().isEmpty())`



#### 小白鼠排队（粗心浪费了不少时间）

```java
import java.util.*;
public class Main{
    public static void main(String[] args){
        Main m = new Main();
        m.func();
    }
    public void func(){
        Scanner sc = new Scanner(System.in);
        while(sc.hasNext()){
            int n = sc.nextInt();
            List<Mouse> list = new ArrayList<>();
            while(n > 0){
                list.add(new Mouse(sc.nextInt(), sc.next()));
                n--;
            }
            //System.out.println(list.get(0).weight + list.get(0).color);
            Collections.sort(list, new Comparator<Mouse>(){
                public int compare(Mouse o1, Mouse o2){
                    return o2.weight - o1.weight;
                }
            });
            //System.out.println(list.get(0).weight + list.get(0).color);
            for(int i = 0; i < list.size(); i++){
                System.out.println(list.get(i).color);
            }
        }
    }
}
class Mouse{
    int weight;
    String color;
    Mouse(int w, String c){
        weight = w;
        color = c;
    }
}
```

##### bug

在前面对`n--`之后`n=0`了，后面就不能用`i<n`来做循环的条件，要用`list.size()`

以后还是用for循环，别改n的值了



#### 圈圈分糖果（数组边界：只有一个元素）

```java

import java.util.Scanner;

public class Main {
    public static void main(String[] args){
        Main m = new Main();
        m.func();
    }
    public void func(){
        Scanner sc = new Scanner(System.in);
        while(sc.hasNext()){
            int n = sc.nextInt();
            int[] nums = new int[n];
            int[] half = new int[n];
            for(int i = 0; i < n; i++){
                nums[i] = sc.nextInt();
                half[i] = nums[i] / 2;
            }
            int count = 0;
            if(n == 1){
                System.out.println(count + " " + nums[0]);
                continue;
            }
            boolean flag = true;
            while(true){
                for(int i = 0; i < n; i++){
                    nums[i] = nums[i] - half[i] + half[(i + n - 1) % n];
                    if(nums[i] % 2 == 1){
                        nums[i] += 1;
                    }
                }

                for(int i = 0; i < n; i++){
                    half[i] = nums[i] / 2;
                }
                flag = true;
                for(int i = 0; i < n - 1; i++){
                    if(nums[i] != nums[i + 1]){
                        flag = false;
                    }
                }
                count++;
                if(flag){
                    System.out.println(count + " " + nums[0]);
                    break;
                }
            }
        }
    }
}
```

##### bug

+ 必须有一个Half数组来暂存原来的数组值
+ 漏掉了数组只有一个元素的边界值导致没有完全通过测试

#### 放苹果（动态规划）

```java
import java.util.*;
public class Main{
    public static void main(String[] args){
        Main m = new Main();
        m.func();
    }
    private void func(){
        Scanner sc = new Scanner(System.in);
        //int n = sc.nextInt();
        int apple, plate;
        while(sc.hasNext()){
            apple = sc.nextInt();
            plate = sc.nextInt();
            if(plate > apple)
                plate = apple;
            int[][] dp = new int[apple + 1][plate + 1];
            for(int i = 1; i < plate + 1; i++){
                dp[0][i] = 1;
            }
            for(int i = 1; i < apple + 1; i++){
                for(int j = 1; j < plate + 1; j++){
                    if(i < j){
                        dp[i][j] = dp[i][i];
                    }
                    else{
                        dp[i][j] = dp[i][j - 1] + dp[i - j][j];
                    }
                }
            }
            System.out.println(dp[apple][plate]);
            //n--;
        }
    }
}
```

##### bug

+ 矩阵内部也需要考虑 i < j 的情况

#### 滑动窗口的最大值

给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}

```java
import java.util.*;
public class Solution {
    public ArrayList<Integer> maxInWindows(int [] num, int size)
    {
        ArrayList<Integer> res = new ArrayList<>();
        if(num.length == 0 || size < 1 || num == null){
            return res;
        }
        PriorityQueue<Integer> queue = new PriorityQueue<Integer>(new Comparator<Integer>(){
            public int compare(Integer o1, Integer o2){
                return o2 - o1;
            }
        });
        int count = 0;
        int max;
        for(int i = 0; i < num.length - size + 1; i++){
            while(count < size){
                queue.add(num[i + count]);
                count++;
            }
            max = queue.peek();
            res.add(max);
            queue.clear();
            count = 0;
        }
        return res;
    }
}
```

+ 用最朴素的做法就可以了，优先级队列方便找最大值
+ count用来计算现在入队了几个，不一定要用，有一个表示入队边界的就行

#### 抓捕孔连顺

给定N（可选作为埋伏点的建筑物数）、D（相距最远的两名特工间的距离的最大值）以及可选建筑的坐标，计算在这次行动中，大锤的小队有多少种埋伏选择。

注意：

1. 两个特工不能埋伏在同一地点

2. 三个特工是等价的：即同样的位置组合(A, B, C) 只算一种埋伏方法，不能因“特工之间互换位置”而重复使用

```java
import java.util.*;
 
public class Main {
    public static void main(String[] args){
        Main m = new Main();
        m.func();
    }
    public void func(){
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int d = sc.nextInt();
        long res = 0;
        int[] positions = new int[n];
 
        for(int i = 0; i < n; i++){
            positions[i] = sc.nextInt();
        }
 
        for(int i = 0; i < n - 2; i++){
            int j = find(positions,positions[i] + d);
            if(j - i < 2){
                continue;
            }
           
            res += calC(j - i);
             
        }
        res %= 99997867;
        System.out.println(res);
    }
     
    public int find(int[] pos, int target){
        int low = 0, high = pos.length - 1;
        int mid;
        while(low <= high){
            mid = low + (high - low) / 2;
            if(pos[mid] == target){
                return mid;
            }
            else if(pos[mid] < target){
                low = mid + 1;
            }
            else{
                high = mid - 1;
            }
        }
        return low - 1;
    }
    private long calC(long num) {
        return num * (num - 1) / 2;
    }
}
```

##### bug

+ 计算个数时应该用乘的，一个一个加会超时
+ 得用一个函数把int变成long，不然会溢出

#### 最大差值（难度为简单但是死活没想出来这个怎么做）

有一个长为n的数组A，求满足0≤a≤b<n的A[b]-A[a]的最大值。

给定数组**A**及它的大小**n**，请返回最大差值。

[10, 5] 2  返回 0

```java
import java.util.*;

public class LongestDistance {
    public int getDis(int[] A, int n) {
        // write code here
        if(n == 1) return 0;
        int result = 0;
        int temp = 0;
        int min = A[0];
        for(int i = 1; i < n; i++){
            if(A[i] < min){
                min = A[i];
            }
            temp = A[i] - min;
            result = Math.max(result, temp);
            
        }
        
        return result;
    }
}
```

思路就是所有的值都去减掉它左边最小的值，取最大的就行，关键就是要不断地保持最小的值和最大的差值

#### 拜访（动态规划）

现在有一个城市销售经理，需要从公司出发，去拜访市内的商家，已知他的位置以及商家的位置，但是由于城市道路交通的原因，他只能在左右中选择一个方向，在上下中选择一个方向，现在问他有多少种方案到达商家地址。

给定一个地图**map**及它的长宽**n**和**m**，其中1代表经理位置，2代表商家位置，-1代表不能经过的地区，0代表可以经过的地区，请返回方案数，保证一定存在合法路径。保证矩阵的长宽都小于等于10。

测试样例：

```
[[0,1,0],[2,0,0]],2,3
返回：2
```

> 链接：https://www.nowcoder.com/questionTerminal/12cbdcdf5d1e4059b6ddd420de6342b6?f=discussion
> 来源：牛客网
>
> 题目描述有点模糊，通过测试才发现，“他只能在左右中选择一个方向，在上下中选择一个方向”应该理解为：左右中只能选一个方向，若选择左只能一直向左走。上下中只能选择一个方向，若选择下只能一直向下。 
>
>   解题思路： 
>
>   1.首先找到1和2的位置，这里要注意一点，从1走到2与从2走到1所得的路径数相同，即以1为起点或以2为起点是等价的。所以我做的处理是，统一从行坐标小的位置走到行坐标大的位置，即向下走。 
>
>   2.1和2的相对位置可以归纳如下： 
>
>   （1）两者位于主对角线上 
>
>   （2）两者位于副对角线上

```java
import java.util.*;

public class Visit {
    public int countPath(int[][] map, int n, int m) {
        // write code here
        int x1 = 0, y1 = 0, x2 = 0, y2 = 0;
        for(int i = 0; i < n; i++){
            for(int j = 0; j < m; j++){
                if(map[i][j] == 1){
                    x1 = i;
                    y1 = j;
                }
                else if(map[i][j] == 2){
                    x2 = i;
                    y2 = j;
                }
            }
        }
        if(x1 == x2 || y1 == y2) return 1;
        if(x1 > x2){
            int temp = x2;
            x2 = x1;
            x1 = temp;
            temp = y2;
            y2 = y1;
            y1 = temp;
        }
        int[][] dp = new int[n][m];
        if(y1 < y2){
            dp[x1][y1] = 1;
            for (int i = x1 + 1; i <= x2; i++) {
                dp[i][y1] = map[i][y1] == -1 ? 0 : dp[i-1][y1];
            }
            for (int j = y1 + 1; j <= y2; j++) {
                dp[x1][j] = map[x1][j] == -1 ? 0 : dp[x1][j-1];
            }
            for(int i = x1 + 1; i <= x2; i++){
                for(int j = y1 + 1; j <= y2; j++){
                    dp[i][j] = map[i][j] == -1 ? 0 : dp[i][j - 1] + dp[i - 1][j];
                }
            }
        }
        else{
            dp[x1][y1] = 1;
            for (int i = x1 + 1; i <= x2; i++) {
                dp[i][y1] = map[i][y1] == -1 ? 0 : dp[i-1][y1];
            }
            for (int j = y1 + 1; j >= y2; j--) {
                dp[x1][j] = map[x1][j] == -1 ? 0 : dp[x1][j+1];
            }
            for(int i = x1 + 1; i <= x2; i++){
                for(int j = y1 - 1; j >= y2; j--){
                    dp[i][j] = map[i][j] == -1 ? 0 : dp[i][j + 1] + dp[i - 1][j];
                }
            }
        }
        return dp[x2][y2];
    }
}
```

+ 和普通的走格子dp不一样的地方是有的格子不能走，只要加个判断就行
+ 注意一下dp[i\][j] = dp[i\][j+1] + dp[i-1\][j] (是加的不是取最大的)

#### 直方图内最大矩形

暴力解法：对每个点向两边寻找，找到以这个点的高度能构造出的最大矩形

```java
import java.util.*;

public class MaxInnerRec {
    public int countArea(int[] A, int n) {
        // write code here
        int left, right, max = 0;
        for(int i = 0; i < n; i++){
            
            for(left = i - 1; left >= 0; left--){
                if(A[left] < A[i]){
                    break;
                }
            }
            for(right = i + 1; right < n; right++){
                if(A[right] < A[i]){
                    break;
                }
            }
            max = Math.max(max, A[i] * (right - left - 1));
        }
        return max;
    }
}
```

动态规划/分治

```java
/**
 * 类似快排的算法。计算当前子数组的最大矩阵面积，是子数组的长度*子数组的最小值。
 * 然后以最小值的下标为分割点，递归的计算左右子数组的最大矩阵面积。
 * 时间复杂度O(nlgn)，空间复杂度O(1)。 * 
 **/
public class MaxInnerRec {
    public int countArea(int[] A, int n) {
        // write code here
    	return countCore(A,0,n-1);
    }
    
    private int countCore(int[] A , int left , int right){
        if(left>right)
    	    return 0;
        if(left==right)
    	    return A[left];
        int highIndex = findMin(A,left,right);
        int max = (right-left+1)*A[highIndex];
        max = Math.max(max, countCore(A,left,highIndex-1));
        max = Math.max(max, countCore(A,highIndex+1,right));
        return max;
    }
    
    private int findMin(int[] A , int left , int right){
        int min = left;
        for(int i=left+1;i<=right;i++)
        if(A[i]<A[min])
    	        min = i;
        return min;
    }
}
```

> 每一轮递归中，比当前计算出的矩形更大的矩形，只可能存在于最小值的左边或者右边，不可能跨越最小值

#### 平均年龄

已知某公司总人数为W，平均年龄为Y岁(每年3月末计算，同时每年3月初入职新人)，假设每年离职率为x，x>0&&x<1,每年保持所有员工总数不变进行招聘，新员工平均年龄21岁。
从今年3月末开始，请实现一个算法，可以计算出第N年后公司员工的平均年龄。(最后结果向上取整)。

```java
import java.util.*;
public class Main{
    public static void main(String[] args){
        Main m = new Main();
        m.func();
    }
    public void func(){
        Scanner sc = new Scanner(System.in);
        int w, y, n, res;
        float sum, x;
        while(sc.hasNext()){
            w = sc.nextInt();
            y = sc.nextInt();
            x = sc.nextFloat();
            n = sc.nextInt();
            sum = y;
            for(int i = 0; i < n; i++){
                sum = (1 - x) * (sum + 1) + 21 * x;
            }
            res = (int)Math.ceil(sum);
            System.out.println(res);
        }
    }
}
```

+ 要注意每过一年老员工会长一岁
+ 使用Math.ceil来向上取整

#### 回文子串的个数（DP）

```java
import java.util.*;
public class Main{
    public static void main(String[] args){
        Main m = new Main();
        m.func();
    }
    public void func(){
        Scanner sc = new Scanner(System.in);
        String s = sc.next();
        int len = s.length();
        int res = 0;
        boolean[][] dp = new boolean[len][len];
        for(int j = 0; j < len; j++){
            for(int i = 0; i <= j; i++){
                if(s.charAt(i) == s.charAt(j) && (j - i < 2 || dp[i + 1][j - 1])){
                    dp[i][j] = true;
                    res++;
                }
            }
        }
        System.out.println(res);
    }
}
```

##### bug

+ for循环的顺序很重要，先 j 后 i
+ 一开始把问题复杂化了，其实只要用N^2的循环去判断子串是不是回文串，在判断时借助前面DP的结果就行

#### 合并金币（区间DP）

```java
import java.util.*;
public class Main{
    public static void main(String[] args){
        Main m = new Main();
        m.func();
    }
    public void func(){
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int[] coin = new int[n];
        int[][] sum = new int[n][n];
        int[][] dp = new int[n][n];
        for(int i = 0; i < n; i++){
            for(int j = 0; j < n; j++){
                dp[i][j] = Integer.MAX_VALUE;
            }
        }
        for(int i = 0; i < n; i++){
            coin[i] = sc.nextInt();
            dp[i][i] = 0;
            sum[i][i] = coin[i];
        }
        for(int len = 1; len < n; len++){
            for(int i = 0; i < n - len; i++){
                sum[i][i + len] = sum[i][i] + sum[i + 1][i + len];
                for(int k = i; k < i + len; k++){
                    dp[i][i + len] = Math.min(dp[i][i + len], dp[i][k] + dp[k + 1][i + len] + sum[i][i + len]);
                }
            }
        }
        System.out.println(dp[0][n - 1]);
    }
}
```

https://blog.csdn.net/weixin_43939593/article/details/105406704

#### 二维数组中的查找

在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。

```
输入：7,[[1,2,8,9],[2,4,9,12],[4,7,10,13],[6,8,11,15]]
输出：true
```

```java
public class Solution {
    public boolean Find(int target, int [][] array) {
        int left = array[0].length;
        for(int i = 0; i < array.length; i++){
            for(int j = 0; j < left; j++){
                if(array[i][j] == target){
                    return true;
                }
                else if(array[i][j] > target){
                    left = j;
                }
                if(left == 0) return false;
            }
        }
        return false;
    }
}
```

