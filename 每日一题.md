### 每日一题

#### 9.23 326 3的幂

给定一个整数，写一个函数来判断它是否是 3 的幂次方。

首先可以判断n是否大于0，3的幂次方必须大于0

```java
class Solution {
    public boolean isPowerOfThree(int n) {
        if(n <= 0) return false;
        while(n > 1){
            if(n % 3 != 0) return false;
            n /= 3;
        }
        return n == 1;
    }
}
```

如果不用循环和递归的话

> 我们还可以使用一种较为取巧的做法。
>
> 在题目给定的 32 位有符号整数的范围内，最大的3的幂为 3^19 = 11622614673。我们只需要判断 n 是否是 3^19的约数即可。

```java
class Solution {
    public boolean isPowerOfThree(int n) {
        return n > 0 && 1162261467 % n == 0;
    }
}
```



#### 9.24 430 扁平化多级双向链表（DFS递归）

多级双向链表中，除了指向下一个节点和前一个节点指针之外，它还有一个子链表指针，可能指向单独的双向链表。这些子列表也可能会有一个或多个自己的子项，依此类推，生成多级数据结构，如下面的示例所示。

给你位于列表第一级的头节点，请你扁平化列表，使所有结点出现在单级双链表中。

我写得有点长了，两个函数很像，只是一个会返回尾结点一个返回头结点

有一个要注意的是next为null时不需要把next和tail连起来

错了两次，一个是没有**把child置为Null**报错了，说不符合规则

一个是在返回尾结点的时候，如果`iter.child != null`**尾结点**不是iter，应该是tail

```java
/*
// Definition for a Node.
class Node {
    public int val;
    public Node prev;
    public Node next;
    public Node child;
};
*/

class Solution {
    public Node flatten(Node head) {
        Node iter = head;
        while(iter != null){
            if(iter.child != null){
                Node tail = flattenReturnTail(iter.child);
                Node next = iter.next;
                if(next != null){
                    tail.next = next;
                    next.prev = tail;
                }
                iter.next = iter.child;
                iter.child.prev = iter;
                iter.child = null;
                iter = next;
            }
            else iter = iter.next;
        }
        return head;
    }
    public Node flattenReturnTail(Node head){
        Node iter = head;
        while(iter != null){
            if(iter.child != null){
                Node tail = flattenReturnTail(iter.child);
                 Node next = iter.next;
                if(next != null){
                    tail.next = next;
                    next.prev = tail;
                }
                iter.next = iter.child;
                iter.child.prev = iter;
                iter.child = null;
                if(next == null) return tail;
                else iter = next;
            }  
            else if(iter.next == null) return iter;
            else iter = iter.next;
        }
        return iter;
    }
}
```

后来我**把tail设置成类成员变量而不是返回值**，把代码改短了

```java
class Solution {
    private Node tail = new Node();
    public Node flatten(Node head){
        Node iter = head;
        while(iter != null){
            if(iter.child != null){
                flatten(iter.child);
                Node next = iter.next;
                if(next != null){
                    tail.next = next;
                    next.prev = tail;
                }
                iter.next = iter.child;
                iter.child.prev = iter;
                iter.child = null;
                
                iter = next;                
            }         
            else {
                if(iter.next == null) tail = iter;//尾结点只有这种可能，如果有child肯定不会是尾结点
                iter = iter.next;
            }
        }
        return head;
    }
}
```

代码里比较繁琐的主要是：

+ 给尾结点赋值的时机
+ iter的下一个取值应该是啥（如果有child，iter接下来应该指向原来的next，没有child，也是指向原来的next，但是写法不太一样

题解的做法也挺有趣，**新写一个把tail做为返回值的函数**，

```java
class Solution {
    public Node flatten(Node head) {
        dfs(head);
        return head;
    }

    public Node dfs(Node node) {
        Node cur = node;
        Node last = null;

        while (cur != null) {
            Node next = cur.next;
            if (cur.child != null) {
                Node childLast = dfs(cur.child);

                next = cur.next;
                //  将 node 与 child 相连
                cur.next = cur.child;
                cur.child.prev = cur;

                //  如果 next 不为空，就将 last 与 next 相连
                if (next != null) {
                    childLast.next = next;
                    next.prev = childLast;
                }

                // 将 child 置为空
                cur.child = null;
                last = childLast; //这里很有趣
            } else {
                last = cur;//这里很有趣
            }
            cur = next;
        }
        return last;
    }
}
```



#### 9.25 583 两个字符串的删除操作（经典DP）

给定两个单词 *word1* 和 *word2*，找到使得 *word1* 和 *word2* 相同所需的最小步数，每步可以删除任意一个字符串中的一个字符。

```java
class Solution {
    public int minDistance(String word1, String word2) {
        int len1 = word1.length();
        int len2 = word2.length();
        int[][] dp = new int[len1 + 1][len2 + 1];//注意！这里要加一
        for(int i = 1; i < len1 + 1; i++){
            dp[i][0] = i;
        }
        for(int j = 0; j < len2 + 1; j++){
            dp[0][j] = j;
        }
        
        for(int i = 1; i < len1 + 1; i++){
            for(int j = 1; j < len2 + 1; j++){
                if(word1.charAt(i - 1) != word2.charAt(j - 1)){
                    dp[i][j] = 1 + Math.min(dp[i][j - 1], dp[i - 1][j]);
                }
                else{
                    dp[i][j] = dp[i - 1][j - 1];
                }
            }
        }
        return dp[len1][len2];
    }
}
```

虽然做过很多次但还是错了好几次，一次是把min写成了max。。还有一次是初始化dp数组的时候忘记+1了



#### 9.26 两整数之和（位运算经典题）

之前做过了，但还是想了一会儿，出了两次错，第一次是把c初始化为0了，直接跳过循环，第二次是没有加括号，不加括号的话会先进行移位操作，我们想要的是先做按位与

```java
class Solution {
    public int getSum(int a, int b) {
        int s = 0, c = 1;//这里c不能为0
        while(c != 0){
            s = a ^ b;
            c = (a & b) << 1;//这里要加括号！
            a = s; 
            b = c;
        }
        return s;
    }
}
```

