### 每日一题

#### 9.23 326 3的幂

给定一个整数，写一个函数来判断它是否是 3 的幂次方。

首先可以判断n是否大于0，3的幂次方必须大于0

```java
class Solution {
    public boolean isPowerOfThree(int n) {
        if(n <= 0) return false;
        while(n > 1){
            if(n % 3 != 0) return false;
            n /= 3;
        }
        return n == 1;
    }
}
```

如果不用循环和递归的话

> 我们还可以使用一种较为取巧的做法。
>
> 在题目给定的 32 位有符号整数的范围内，最大的3的幂为 3^19 = 11622614673。我们只需要判断 n 是否是 3^19的约数即可。

```java
class Solution {
    public boolean isPowerOfThree(int n) {
        return n > 0 && 1162261467 % n == 0;
    }
}
```



#### 9.24 430 扁平化多级双向链表（DFS递归）

多级双向链表中，除了指向下一个结点和前一个结点指针之外，它还有一个子链表指针，可能指向单独的双向链表。这些子列表也可能会有一个或多个自己的子项，依此类推，生成多级数据结构，如下面的示例所示。

给你位于列表第一级的头结点，请你扁平化列表，使所有结点出现在单级双链表中。

我写得有点长了，两个函数很像，只是一个会返回尾结点一个返回头结点

有一个要注意的是next为null时不需要把next和tail连起来

错了两次，一个是没有**把child置为Null**报错了，说不符合规则

一个是在返回尾结点的时候，如果`iter.child != null`**尾结点**不是iter，应该是tail

```java
/*
// Definition for a Node.
class Node {
    public int val;
    public Node prev;
    public Node next;
    public Node child;
};
*/

class Solution {
    public Node flatten(Node head) {
        Node iter = head;
        while(iter != null){
            if(iter.child != null){
                Node tail = flattenReturnTail(iter.child);
                Node next = iter.next;
                if(next != null){
                    tail.next = next;
                    next.prev = tail;
                }
                iter.next = iter.child;
                iter.child.prev = iter;
                iter.child = null;
                iter = next;
            }
            else iter = iter.next;
        }
        return head;
    }
    public Node flattenReturnTail(Node head){
        Node iter = head;
        while(iter != null){
            if(iter.child != null){
                Node tail = flattenReturnTail(iter.child);
                 Node next = iter.next;
                if(next != null){
                    tail.next = next;
                    next.prev = tail;
                }
                iter.next = iter.child;
                iter.child.prev = iter;
                iter.child = null;
                if(next == null) return tail;
                else iter = next;
            }  
            else if(iter.next == null) return iter;
            else iter = iter.next;
        }
        return iter;
    }
}
```

后来我**把tail设置成类成员变量而不是返回值**，把代码改短了

```java
class Solution {
    private Node tail = new Node();
    public Node flatten(Node head){
        Node iter = head;
        while(iter != null){
            if(iter.child != null){
                flatten(iter.child);
                Node next = iter.next;
                if(next != null){
                    tail.next = next;
                    next.prev = tail;
                }
                iter.next = iter.child;
                iter.child.prev = iter;
                iter.child = null;
                
                iter = next;                
            }         
            else {
                if(iter.next == null) tail = iter;//尾结点只有这种可能，如果有child肯定不会是尾结点
                iter = iter.next;
            }
        }
        return head;
    }
}
```

代码里比较繁琐的主要是：

+ 给尾结点赋值的时机
+ iter的下一个取值应该是啥（如果有child，iter接下来应该指向原来的next，没有child，也是指向原来的next，但是写法不太一样

题解的做法也挺有趣，**新写一个把tail做为返回值的函数**，

```java
class Solution {
    public Node flatten(Node head) {
        dfs(head);
        return head;
    }

    public Node dfs(Node node) {
        Node cur = node;
        Node last = null;

        while (cur != null) {
            Node next = cur.next;
            if (cur.child != null) {
                Node childLast = dfs(cur.child);

                next = cur.next;
                //  将 node 与 child 相连
                cur.next = cur.child;
                cur.child.prev = cur;

                //  如果 next 不为空，就将 last 与 next 相连
                if (next != null) {
                    childLast.next = next;
                    next.prev = childLast;
                }

                // 将 child 置为空
                cur.child = null;
                last = childLast; //这里很有趣
            } else {
                last = cur;//这里很有趣
            }
            cur = next;
        }
        return last;
    }
}
```



#### 9.25 583 两个字符串的删除操作（经典DP）

给定两个单词 *word1* 和 *word2*，找到使得 *word1* 和 *word2* 相同所需的最小步数，每步可以删除任意一个字符串中的一个字符。

```java
class Solution {
    public int minDistance(String word1, String word2) {
        int len1 = word1.length();
        int len2 = word2.length();
        int[][] dp = new int[len1 + 1][len2 + 1];//注意！这里要加一
        for(int i = 1; i < len1 + 1; i++){
            dp[i][0] = i;
        }
        for(int j = 0; j < len2 + 1; j++){
            dp[0][j] = j;
        }
        
        for(int i = 1; i < len1 + 1; i++){
            for(int j = 1; j < len2 + 1; j++){
                if(word1.charAt(i - 1) != word2.charAt(j - 1)){
                    dp[i][j] = 1 + Math.min(dp[i][j - 1], dp[i - 1][j]);
                }
                else{
                    dp[i][j] = dp[i - 1][j - 1];
                }
            }
        }
        return dp[len1][len2];
    }
}
```

虽然做过很多次但还是错了好几次，一次是把min写成了max。。还有一次是初始化dp数组的时候忘记+1了



#### 9.26 371 两整数之和（位运算经典题）

之前做过了，但还是想了一会儿，出了两次错，第一次是把c初始化为0了，直接跳过循环，第二次是没有加括号，不加括号的话会先进行移位操作，我们想要的是先做按位与。

```java
class Solution {
    public int getSum(int a, int b) {
        int s = 0, c = 1;//这里c不能为0
        while(c != 0){
            s = a ^ b;
            c = (a & b) << 1;//这里要加括号！
            a = s; 
            b = c;
        }
        return s;
    }
}
```



#### 9.27 639 解码方法 II （需要分好多类讨论的线性DP）

> 一条包含字母 A-Z 的消息通过以下的方式进行了编码：
>
> 'A' -> 1
> 'B' -> 2
> ...
> 'Z' -> 26
> 要 解码 一条已编码的消息，所有的数字都必须分组，然后按原来的编码方案反向映射回字母（可能存在多种方式）。例如，"11106" 可以映射为：
>
> "AAJF" 对应分组 (1 1 10 6)
> "KJF" 对应分组 (11 10 6)
> 注意，像 (1 11 06) 这样的分组是无效的，因为 "06" 不可以映射为 'F' ，因为 "6" 与 "06" 不同。
>
> 除了 上面描述的数字字母映射方案，编码消息中可能包含 '\*' 字符，可以表示从 '1' 到 '9' 的任一数字（不包括 '0'）。例如，编码字符串 "1\*" 可以表示 "11"、"12"、"13"、"14"、"15"、"16"、"17"、"18" 或 "19" 中的任意一条消息。对 "1*" 进行解码，相当于解码该字符串可以表示的任何编码消息。
>
> 给你一个字符串 s ，由数字和 '*' 字符组成，返回 解码 该字符串的方法 数目 。
>
> 由于答案数目可能非常大，返回对 1e9 + 7 取余 的结果。

首先这道题可以想到dp，但我没想出来怎么dp（怎么写状态转移方程），还是不争气地看了题解，才意识到对每个正在计算有几种编码方案的字符串来说，不需要去考虑所有的切法，比如一个长度为5的字符串，我一开始以为要把1，4；2，3；3，2；4，1的都加起来，其实在算4的时候就已经把3和2的数量涵盖在内了，所以这种做法是错的。只需要考虑最后的字符怎么分就行了，这种思想很像青蛙跳台阶，只要考虑最后一次是跳一格还是两格就行了。同理，这题只要算出

f(n-2)\*最后两个字符的方案数 和 f(n-1)\*最后一个字符的方案数就行了，一定要注意这里是乘不是加

我写出来的还是有点长，一开始把dp数组声明为int型吃了不少苦头，后来还是改成了long

```java
class Solution {
    public int numDecodings(String s) {
        if(s.charAt(0) == '0') return 0;
        long[] dp = new long[s.length() + 1];
        int mod = (int)1e9 + 7;//1e9不是int型，这也是我没想到的
        dp[0] = 1;
        dp[1] = s.charAt(0) == '*' ? 9 : 1;
        
        for(int i = 2; i < dp.length; i++){
            if(s.charAt(i - 1) == '*'){
                dp[i] += dp[i - 1] * 9;
                if(s.charAt(i - 2) == '1'){
                    dp[i] += dp[i - 2] * 9;
                }
                else if(s.charAt(i - 2) == '2'){
                    dp[i] += dp[i - 2] * 6;
                }
                else if(s.charAt(i - 2) == '*'){//一开始漏了这里
                    dp[i] += dp[i - 2] * 15;
                }
            }
            else if(s.charAt(i - 1) == '0'){
                if(s.charAt(i - 2) == '1' || s.charAt(i - 2) == '2'){
                    dp[i] += dp[i - 2];
                }
                else if(s.charAt(i - 2) == '*'){//一开始漏了这里
                    dp[i] += dp[i - 2] * 2;
                }                   
            }
            else{
                dp[i] += dp[i - 1];
                if(s.charAt(i - 2) == '0') continue;
                if(s.charAt(i - 2) == '*'){//一开始漏了这里
                    if(s.charAt(i - 1) > '6'){
                        dp[i] += dp[i - 2];
                    }
                    else{
                        dp[i] += dp[i - 2] * 2;
                    }
                }
                else if((s.charAt(i - 2) - '0') * 10 + (s.charAt(i - 1) - '0') <= 26){
                    dp[i] += dp[i - 2];
                }
            }
            dp[i] %= mod;
        }
        return (int)dp[dp.length - 1];
    }
}
```

可以优化一下空间，其实只需要3个long用来存结果就行了，不需要一整个数组，不过我改了半天代码结果还更差了。。。无语

```java
class Solution {
    public int numDecodings(String s) {
        if(s.charAt(0) == '0') return 0;
        long[] dp = new long[3];
        int mod = (int)1e9 + 7;
        dp[0] = 1;
        dp[1] = s.charAt(0) == '*' ? 9 : 1;
        
        for(int i = 2; i < s.length() + 1; i++){
            long cnt = 0;
            int pre1 = (i - 1) % 3;
            int pre2 = (i - 2) % 3;
            if(s.charAt(i - 1) == '*'){
                cnt += dp[pre1] * 9;
                if(s.charAt(i - 2) == '1'){
                    cnt += dp[pre2] * 9;
                }
                else if(s.charAt(i - 2) == '2'){
                    cnt += dp[pre2] * 6;
                }
                else if(s.charAt(i - 2) == '*'){
                    cnt += dp[pre2] * 15;
                }
            }
            else if(s.charAt(i - 1) == '0'){
                if(s.charAt(i - 2) == '1' || s.charAt(i - 2) == '2'){
                    cnt += dp[pre2];
                }
                else if(s.charAt(i - 2) == '*'){
                    cnt += dp[pre2] * 2;
                }                   
            }
            else{
                cnt += dp[pre1];
                if(s.charAt(i - 2) != '0') {
                    if(s.charAt(i - 2) == '*'){
                        if(s.charAt(i - 1) > '6'){
                            cnt += dp[pre2];
                        }
                        else{
                            cnt += dp[pre2] * 2;
                        }
                    }
                    else if((s.charAt(i - 2) - '0') * 10 + (s.charAt(i - 1) - '0') <= 26){
                        cnt += dp[pre2];
                    }
                }
                
            }
            dp[i % 3] = cnt % mod;
        }
        return (int)dp[s.length() % 3];
    }
}
```



#### 9.28 437 路径总和III（二叉树经典题，递归，dp，前缀和，backtracking）

给定一个二叉树的根结点 root ，和一个整数 targetSum ，求该二叉树里结点值之和等于 targetSum 的 路径 的数目。

路径 不需要从根结点开始，也不需要在叶子结点结束，但是路径方向必须是向下的（只能从父结点到子结点）。

我只想到了dp+递归，而且一开始还卡了一会儿，后来才想明白要写两个递归函数，都是表示从当前结点向下有几种路径，但With Root函数表示路径包含从当前结点。

总体思路就是拆分成三类，一个是根结点的左子树有几种，一个是根结点的右子树有几种，一个是从根结点出发有几种，其中从根结点出发还需要额外考虑单独根结点是否满足条件。

```java
class Solution {
    public int pathSum(TreeNode root, int targetSum) {
        if(root == null) return 0;
        int sum = 0;  
        if(root.left != null) sum += pathSum(root.left, targetSum);
        if(root.right != null) sum += pathSum(root.right, targetSum);
        sum += pathSumWithRoot(root, targetSum);   
        
        return sum;
    }
    public int pathSumWithRoot(TreeNode root, int targetSum) {
        if(root == null) return 0;
        int sum = 0;
        if(root.val == targetSum) sum++;
        if(root.left != null) sum += pathSumWithRoot(root.left, targetSum - root.val);
        if(root.right != null) sum += pathSumWithRoot(root.right, targetSum - root.val);

        return sum;
    }
}
```

这种做法会导致非常多的重复计算，后来看了题解的利用前缀和的做法，重新写了一次

```java
class Solution {   
    public int pathSum(TreeNode root, int targetSum){
        Map<Integer, Integer> map = new HashMap<>();
        map.put(0, 1);//这一步很重要
        return dfs(root, 0, targetSum, map);
    }
    public int dfs(TreeNode root, int preSum, int targetSum, Map<Integer, Integer> map){
        if(root == null) return 0;
        int ret = 0;
        int curSum = preSum + root.val;
        ret += map.getOrDefault(curSum - targetSum, 0);
        map.put(curSum, map.getOrDefault(curSum, 0) + 1);
        ret += dfs(root.left, curSum, targetSum, map);
        ret += dfs(root.right, curSum, targetSum, map);
        map.put(curSum, map.get(curSum) - 1);
        return ret;
    }
}
```

这一次就快多了，两种做法给我的感觉是第一种是从上往下找路径，第二种是从下往上找路径，即，对当前遍历到的结点计算前缀和（从根结点到当前结点的路径上的和），再判断这条路径上是否有前缀和为`curSum - targetSum`的，然后再递归遍历左右子树，最后要把当前结点的前缀和从map中移除，这里的思想又类似backtracking。这道题还是考察了蛮多点的

- 对于空路径我们也需要保存预先处理一下，此时因为空路径不经过任何节点，因此它的前缀和为 0。

一开始我很困惑的点还包括map的key和value是啥，后来才明白key是前缀和，value是个数。具体的结点不需要去记录。map中存放的其实相当于从根结点开始的**一条**路径的所有前缀和

另一个有趣的地方是`targetSum`其实是不变的，这点和第一种做法不太一样。传给递归函数的第二个参数用来保存前面的前缀和



#### 9.29 517 超级洗衣机（贪心）

假设有 n 台超级洗衣机放在同一排上。开始的时候，每台洗衣机内可能有一定量的衣服，也可能是空的。

在每一步操作中，你可以选择任意 m (1 <= m <= n) 台洗衣机，与此同时将每台洗衣机的一件衣服送到相邻的一台洗衣机。

给定一个整数数组 machines 代表从左至右每台洗衣机中的衣物数量，请给出能让所有洗衣机中剩下的衣物的数量相等的 最少的操作步数 。如果不能使每台洗衣机中衣物的数量相等，则返回 -1 。

没看出来是贪心，毫无思路直接看了题解，https://leetcode-cn.com/problems/super-washing-machines/solution/gong-shui-san-xie-noxiang-xin-ke-xue-xi-mzqia/

我的理解是，不用管到底是怎么选的，到底是怎么送的，我们只需要考虑最终的从高往低的流动，看题目给的示例

> 输入：machines = [1,0,5]
> 输出：3
> 解释：
> 第一步:    1     0 <-- 5    =>    1     1     4
>
> 第二步:    1 <-- 1 <-- 4   =>    2     1     3 
>
> 第三步:    2     1 <-- 3    =>    2     2     2   

最优的方案必然会尽可能利用每一次选择和移动，因此只需要找到那台箭头最多的，它的箭头数就是最少的操作步数，因为每台洗衣机每次只能移动一次

而每台洗衣机所指出的箭头数其实就是这台洗衣机**左侧的衣服增加量+右侧的衣服增加量**，如果是减少则算成0，因为一侧的减少其实就是另一侧的增加

再对所有的（左加右）取最大值即可



我用了前缀和写了下面这个：

```java
class Solution {
    public int findMinMoves(int[] machines) {
        int len = machines.length;
        int[] sum = new int[len + 1];
        for(int i = 0; i < len; i++){
            sum[i + 1] = sum[i] + machines[i];
        }
        if(sum[len] % len != 0) return -1;
        int average = sum[len] / len; 
        int res = 0;
        for(int i = 0; i < len; i++){
            int a = Math.max(0, average * i - sum[i]);
            int b = Math.max(0, average * (len - i - 1) - (sum[len] - sum[i + 1]));
            res = Math.max((a + b), res);
        }
        return res;
    }
}
```

题解里没有用数组存，直接存在了rs和ls两个变量里，每次遍历的时候修改rs和ls的值

```java
class Solution {
    public int findMinMoves(int[] machines) {
        int len = machines.length;
        int sum = 0;
        for(int i = 0; i < len; i++){
            sum += machines[i];
        }
        if(sum % len != 0) return -1;
        int average = sum / len; 
        int res = 0, rs = sum, ls = 0;
        for(int i = 0; i < len; i++){
            rs -= machines[i];
            int a = Math.max(0, average * i - ls);
            int b = Math.max(0, average * (len - i - 1) - rs);
            res = Math.max((a + b), res);            
            ls += machines[i];
        }
        return res;
    }
}
```

但是实际内存消耗几乎没差，时间也几乎没差



#### 9.30 223 矩形面积（很容易想复杂的题）

给你 二维 平面上两个 由直线构成的 矩形，请你计算并返回两个矩形覆盖的总面积。

每个矩形由其 左下 顶点和 右上 顶点坐标表示：

第一个矩形由其左下顶点 (ax1, ay1) 和右上顶点 (ax2, ay2) 定义。
第二个矩形由其左下顶点 (bx1, by1) 和右上顶点 (bx2, by2) 定义。

这道题最关键的就是求出两个矩形重合的面积，一开始我画了超级多图，还想着分类讨论，后来发现其实只需要分别算出x轴方向两条线的重叠长度和y轴方向两条线的重叠长度再相乘即可，然后我又对两条线段的情况进行了分类讨论，写出来的代码如下

```java
class Solution {
    public int computeArea(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) {
        int overlapArea = overlap(ax1, ax2, bx1, bx2) * overlap(ay1, ay2, by1, by2);
        return (ay2 - ay1) * (ax2 - ax1) + (by2 - by1) * (bx2 - bx1) - overlapArea;
    }
    public int overlap(int a1, int a2, int b1, int b2){
        if(a1 > b1){
            int tmp1 = a1;
            a1 = b1;
            b1 = tmp1;
            int tmp2 = a2;
            a2 = b2;
            b2 = tmp2;
        }
        if(b1 <= a2 && a2 <= b2) return a2 - b1;
        if(a2 < b1) return 0;
        if(b2 < a2) return b2 - b1; 
        return -1;
    }
}
```

后来看了题解发现自己写的还是太复杂了，其实也不需要分类讨论，两条线段的重叠长度就是 `Math.min(a2, b2) - Math.max(a1, b1)`，如果结果小于0说明不重复，返回0

```java
class Solution {
    public int computeArea(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) {
        int overlapArea = overlap(ax1, ax2, bx1, bx2) * overlap(ay1, ay2, by1, by2);
        return (ay2 - ay1) * (ax2 - ax1) + (by2 - by1) * (bx2 - bx1) - overlapArea;
    }
    public int overlap(int a1, int a2, int b1, int b2){
        int res = Math.min(a2, b2) - Math.max(a1, b1);
        return res < 0 ? 0 : res;
    }
}
```

不过时间和内存的结果上还是差不多的



#### 10.1 1436 旅行终点站（easy）

给你一份旅游线路图，该线路图中的旅行线路用数组 paths 表示，其中 paths[i] = [cityAi, cityBi] 表示该线路将会从 cityAi 直接前往 cityBi 。请你找出这次旅行的终点站，即没有任何可以通往其他城市的线路的城市。

题目数据保证线路图会形成一条不存在循环的线路，因此恰有一个旅行终点站。

> 示例 1：
>
> 输入：paths = [["London","New York"],["New York","Lima"],["Lima","Sao Paulo"]]
> 输出："Sao Paulo" 
> 解释：从 "London" 出发，最后抵达终点站 "Sao Paulo" 。本次旅行的路线是 "London" -> "New York" -> "Lima" -> "Sao Paulo" 。

这道题不难，我用了一个set来存所有可能是结果的城市，即所有的cityBi，然后再遍历一遍查看是否有cityBi同时是cityAi，有的话就把它从set里删掉

```java
class Solution {
    public String destCity(List<List<String>> paths) {
        Set<String> destCitys = new HashSet<>();
        for(List<String> path : paths){
            destCitys.add(path.get(1));
        }
        for(List<String> path : paths){           
            if(destCitys.contains(path.get(0))){
                destCitys.remove(path.get(0));
            }
        }
        for(String city : destCitys){
            return city;
        }
        return "";
    }
}
```

但题解的做法更快一些，它的思路和我的正好相反，它先遍历一遍把所有的cityAi存下来，然后遍历cityBi，看哪个cityBi不在cityAi的set里，这个就是最后的终点，这样可以提前返回结果

```java
class Solution {
    public String destCity(List<List<String>> paths) {
        Set<String> citys = new HashSet<>();
        for(List<String> path : paths){
            citys.add(path.get(0));
        }
        for(List<String> path : paths){           
            if(!citys.contains(path.get(1))){
                return path.get(1);
            }
        }
        return "";
    }
}
```



#### 10.2 405 数字转换为16进制数（位运算）

给定一个整数，编写一个算法将这个数转换为十六进制数。对于负整数，我们通常使用 补码运算 方法。

注意:

十六进制中所有字母(a-f)都必须是小写。
十六进制字符串中不能包含多余的前导零。如果要转化的数为0，那么以单个字符'0'来表示；对于其他情况，十六进制字符串中的第一个字符将不会是0字符。 
给定的数确保在32位有符号整数范围内。
不能使用任何由库提供的将数字直接转换或格式化为十六进制的方法。

示例 1：

```
输入:
26
输出:
"1a"
```

示例 2：

```
输入:
-1
输出:
"ffffffff"
```

看到负整数，补码我就放弃思考了，因为补码好混乱，就看了题解 https://leetcode-cn.com/problems/convert-a-number-to-hexadecimal/solution/gong-shui-san-xie-yi-ti-shuang-jie-jin-z-d93o/

第一种做法最方便，是位运算，也不需要考虑正负数，补码啥的。把我们要转换的数看出一个二进制数，它就是用补码表示的32位二进制数，要转成16进制只需要把它四位一组的进行转换即可，用1111对数字进行按位与，就可以拿到最后的四位，然后再把数字无符号右移4位，直到这个数字为0，这样也可以避免前导0，超级方便

```java
class Solution {
    public String toHex(int num) {
        if(num == 0) return "0";
        StringBuilder strb = new StringBuilder();
        while(num != 0){
            int cur = num & 15;
            strb.append(cur < 10 ? (char)(cur + '0') : (char)(cur - 10 + 'a'));//注意这里要强制类型转换成char
            num = num >>> 4;//注意这里是无符号右移
        }
        return strb.reverse().toString();
    }
}
```

第二种做法的通用的进制转换的思路，对于负数只需要**先加上2^32的偏移量**就可以了，但需要有个long型的变量来存



#### 10.3 166 分数到小数（模拟除法）

给定两个整数，分别表示分数的分子 numerator 和分母 denominator，以 字符串形式返回小数 。

如果小数部分为循环小数，则将循环的部分括在括号内。

如果存在多个答案，只需返回 任意一个 。

对于所有给定的输入，保证 答案字符串的长度小于 10^4 。

这题的难点在于小数部分，但其实也没有想象中难，关键就是模拟除法。

> 计算小数部分时，每次将余数乘以 10，然后计算小数的下一位数字，并得到新的余数。重复上述操作直到余数变成 0 或者找到循环节。
>
> 如果余数变成 0，则结果是有限小数，将小数部分拼接到结果中。
>
> 如果找到循环节，则找到循环节的开始位置和结束位置并加上括号，然后将小数部分拼接到结果中。
>
> 如何判断是否找到循环节？注意到对于相同的余数，计算得到的小数的下一位数字一定是相同的，因此如果计算过程中发现某一位的余数在之前已经出现过，则为找到循环节。为了记录每个余数是否已经出现过，需要使用哈希表存储每个余数在小数部分第一次出现的下标。
>
> 链接：https://leetcode-cn.com/problems/fraction-to-recurring-decimal/solution/fen-shu-dao-xiao-shu-by-leetcode-solutio-tqdw/

从人工模拟除法运算的过程，我们就可以知道「为什么不会出现“无限不循环小数”」，因为始终是对余数进行补零操作，再往下进行运算，而余数个数具有明确的上限（有限集）。所以根据抽屉原理，一直接着往下计算，最终结果要么是「出现相同余数」，要么是「余数为 0，运算结束」。

> 一些细节：
>
> 一个显然的条件是，如果本身两数能够整除，直接返回即可；
> 如果两个数有一个为“负数”，则最终答案为“负数”，因此可以起始先判断两数相乘是否小于 0，如果是，先往答案头部追加一个负号 -；
> 两者范围为 int，但计算结果可以会超过 int 范围，因此起始需要先使用 long 对两个入参类型转换一下。
> 链接：https://leetcode-cn.com/problems/fraction-to-recurring-decimal/solution/gong-shui-san-xie-mo-ni-shu-shi-ji-suan-kq8c4/

下面是我根据题解的思路写出的代码

```java
class Solution {
    public String fractionToDecimal(int numerator, int denominator) {
        long a = numerator, b = denominator;
        if(a % b == 0) return String.valueOf(a / b);
        StringBuilder strb = new StringBuilder();
        if(a * b < 0) strb.append('-');
        a = Math.abs(a);
        b = Math.abs(b);
        strb.append(String.valueOf(a / b) + ".");
        int start = strb.length();//这里要注意，第一次直接当做2来处理了
        a = a % b;
        Map<Long, Integer> map = new HashMap<>();
        int i = 0;        
        while(a != 0){
            if(map.containsKey(a)){
                strb.insert(map.get(a) + start, '(');
                strb.append(')');
                return strb.toString();
            }
            map.put(a, i);
            i++;
            a = a * 10;
            strb.append(String.valueOf(a / b));
            a = a % b;    
        }
        return strb.toString();
    }
}
```



#### 10.4 482 密钥格式化（easy）

有一个密钥字符串 S ，只包含字母，数字以及 '-'（破折号）。其中， N 个 '-' 将字符串分成了 N+1 组。

给你一个数字 K，请你重新格式化字符串，使每个分组恰好包含 K 个字符。特别地，第一个分组包含的字符个数必须小于等于 K，但至少要包含 1 个字符。两个分组之间需要用 '-'（破折号）隔开，并且将所有的小写字母转换为大写字母。

给定非空字符串 S 和数字 K，按照上面描述的规则进行格式化。

示例 1：

```
输入：S = "5F3Z-2e-9-w", K = 4
输出："5F3Z-2E9W"
解释：字符串 S 被分成了两个部分，每部分 4 个字符；
     注意，两个额外的破折号需要删掉。
```

示例 2：

```
输入：S = "2-5g-3-J", K = 2
输出："2-5G-3J"
解释：字符串 S 被分成了 3 个部分，按照前面的规则描述，第一部分的字符可以少于给定的数量，其余部分皆为 2 个字符。
```

从后往前遍历不难想到。

这道题比较需要注意的是避免以破折号结尾，我的做法是当第`k*n + 1`个字母出现时再在它前面加破折号，还有小写转大写用`Character.toUpperCase(s.charAt(i))`比较快，用`str.substring(i, i + 1).toUpperCase()`比较慢

```java
class Solution {
    public String licenseKeyFormatting(String s, int k) {
        StringBuilder strb = new StringBuilder();
        int count = 0;
        for(int i = s.length() - 1; i >= 0; i--){
            if(s.charAt(i) == '-') continue;
            if(count > 0 && count % k == 0){
                strb.append('-');
            }    
            strb.append(Character.toUpperCase(s.charAt(i)));
            count++;
        }
        return strb.reverse().toString();
    }
}
```



#### 10.5 284 窥探迭代器（实现一个附加功能的迭代器，有点容易绕晕）

请你设计一个迭代器，除了支持 hasNext 和 next 操作外，还支持 peek 操作。

实现 PeekingIterator 类：

+ PeekingIterator(int[] nums) 使用指定整数数组 nums 初始化迭代器。
+ int next() 返回数组中的下一个元素，并将指针移动到下个元素处。
+ bool hasNext() 如果数组中存在下一个元素，返回 true ；否则，返回 false 。
+ int peek() 返回数组中的下一个元素，但 不 移动指针。

这道题首先需要了解迭代器接口，它有`hasNext()`和`next()`，其次是新增的peek功能需要能返回下一个元素而且不移动指针，所以需要把指针指向的值存起来，调用peek函数的时候不要调用iterator的next

又因为我把值提前存起来了，相当于我提前调用了一次next函数，所以新的迭代器的next函数返回的值其实是iter的前一个的值，就是这里把我绕得很晕

> 实现上，我们可以让操作提前一步进行，事先调用一次 next() 并使用该变量 next存起该元素，通过外部调用 peek() 还是 next() 来决定是否要更新 next；同时由于我们事先存起了下一访问位置的元素，我们可以通过判断 next 是否为 null 来得知是否到达迭代器结尾（hasNext() 实现）。
>
> 链接：https://leetcode-cn.com/problems/peeking-iterator/solution/gong-shui-san-xie-die-dai-qi-ji-ben-ren-b77lz/

```java
// Java Iterator interface reference:
// https://docs.oracle.com/javase/8/docs/api/java/util/Iterator.html

class PeekingIterator implements Iterator<Integer> {
    private Iterator<Integer> iterator;
    private Integer nextElement;

	public PeekingIterator(Iterator<Integer> iterator) {
	    // initialize any member here.
	    this.iterator = iterator;
        this.nextElement = iterator.next();
	}
	
    // Returns the next element in the iteration without advancing the iterator.
	public Integer peek() {
        return nextElement;
	}
	
	// hasNext() and next() should behave the same as in the Iterator interface.
	// Override them if needed.
	@Override
	public Integer next() {
        Integer ret = nextElement;
        nextElement = iterator.hasNext() ? iterator.next() : null;
	    return ret;
	}
	
	@Override
	public boolean hasNext() {
	    return nextElement != null;
	}
}
```



#### 10.6 414 第三大的数

给你一个非空数组，返回此数组中 **第三大的数** 。如果不存在，则返回数组中最大的数。

提示：

```
1 <= nums.length <= 10^4
-2^31 <= nums[i] <= 2^31 - 1
```


进阶：你能设计一个时间复杂度 O(n) 的解决方案吗？

我的思路是拿三个数来存前三大的数，遍历数组一遍，遍历的时候对这三个变量进行修改

```java
class Solution {
    public int thirdMax(int[] nums) {
        long firstMax = Long.MIN_VALUE, secondMax = Long.MIN_VALUE, thirdMax = Long.MIN_VALUE;

        for(int i = 0; i < nums.length; i++){
            if(nums[i] > firstMax){
                thirdMax = secondMax;
                secondMax = firstMax;
                firstMax = nums[i];
            }
            else if(nums[i] == firstMax) continue;
            else if(nums[i] > secondMax){
                thirdMax = secondMax;
                secondMax = nums[i];
            }
            else if(nums[i] == secondMax) continue;
            else if(nums[i] > thirdMax){
                thirdMax = nums[i];                
            }
        }
        if(thirdMax != Long.MIN_VALUE) return (int)thirdMax;
        else return (int)firstMax;
    }
}
```

比较纠结的是三个变量的初始值应该给多少，想来想去只好用long的最小值，因为num的取值范围为int。题解也有一种做法是这样的，另一种是用null来存，如下

```java
class Solution {
    public int thirdMax(int[] nums) {
        Integer a = null, b = null, c = null;
        for (int num : nums) {
            if (a == null || num > a) {
                c = b;
                b = a;
                a = num;
            } else if (a > num && (b == null || num > b)) {
                c = b;
                b = num;
            } else if (b != null && b > num && (c == null || num > c)) {
                c = num;
            }
        }
        return c == null ? a : c;
    }
}
```

题解里还有一种做法是利用有序集，每遍历一个数，就将其插入有序集合，若有序集合的大小超过 3，就删除集合中的最小元素。

```java
class Solution {
    public int thirdMax(int[] nums) {
        TreeSet<Integer> s = new TreeSet<Integer>();
        for (int num : nums) {
            s.add(num);
            if (s.size() > 3) {
                s.remove(s.first());
            }
        }
        return s.size() == 3 ? s.first() : s.last();
    }
}
```



#### 10.7 434 字符串中的单词数

统计字符串中的单词个数，这里的单词指的是连续的不是空格的字符。

请注意，你可以假定字符串里不包括任何不可打印的字符。

一开始我用了java自带的函数

```java
class Solution {
    public int countSegments(String s) {
        s = s.trim();
        if(s.length() == 0) return 0;
        return s.split("\\s+").length;
    }
}
```

然后速度有点慢

看了下官方题解，还蛮巧妙的

> 计算字符串中单词的数量，就等同于计数单词的第一个下标的个数。因此，我们只需要遍历整个字符串，统计每个单词的第一个下标的数目即可。
>
> 满足单词的第一个下标有以下两个条件：
>
> 该下标对应的字符不为空格；
>
> 该下标为初始下标或者该下标的前下标对应的字符为空格；
>

```java
class Solution {
    public int countSegments(String s) {
        int count = 0;
        for(int i = 0; i < s.length(); i++) {
            if((i == 0 || s.charAt(i - 1) == ' ') && s.charAt(i) != ' ') count++;
        }
        return count;
    }
}
```



#### 10.8 187 重复的DNA序列（位运算+hashmap，四种做法）

所有 DNA 都由一系列缩写为 'A'，'C'，'G' 和 'T' 的核苷酸组成，例如："ACGAATTCCG"。在研究 DNA 时，识别 DNA 中的重复序列有时会对研究非常有帮助。

编写一个函数来找出所有目标子串，目标子串的长度为 10，且在 DNA 字符串 s 中出现次数超过一次。

示例 1：

```
输入：s = "AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT"
输出：["AAAAACCCCC","CCCCCAAAAA"]
```

示例 2：

```
输入：s = "AAAAAAAAAAAAA"
输出：["AAAAAAAAAA"]
```

最简单的思路就是把所有的子串放到hashmap，找出次数大于1的子串即可。需要注意的是为了避免重复添加，只要在子串的计数等于2的时候加入结果就行了

```java
class Solution {
    public List<String> findRepeatedDnaSequences(String s) {
        HashMap<String, Integer> map = new HashMap<>();
        List<String> res = new ArrayList<>();
        for(int i = 0; i <= s.length() - 10; i++){
            String pattern = s.substring(i, i + 10);
            map.put(pattern, map.getOrDefault(pattern, 0) + 1);
            if(map.get(pattern) == 2) res.add(pattern);
        }
        return res;
    }
}
```

时间和空间复杂度为O(NL)，其中N是字符串s的长度，L=10即目标子串的长度。	

题解还提供了一种思路，因为一共只有4个字符，所以可以用两个bit表示，00，01，10，11，对应0，1，2，3（我一开始写错成1，2，3，4了），10个字符就是20个bit，可以用一个int装下，所以hashmap可以把key从字符串改成int。

但这样并没有改变时间复杂度，为了优化时间复杂度，可以使用滑动窗口的方法，利用当前的int计算下一个int，这样计算一个子串的时间复杂度就是O(1)

> 设当前滑动窗口对应的整数表示为 x，当我们要计算下一个子串时，就将滑动窗口向右移动一位，此时会有一个新的字符进入窗口，以及窗口最左边的字符离开窗口，这些操作对应的位运算，按计算顺序表示如下：
>
> 滑动窗口向右移动一位：x = x << 2，由于每个字符用 2 个比特表示，所以要左移2位；
> 一个新的字符ch进入窗口：x = x | bin[ch]，这里bin[ch] 为字符ch的对应二进制；
> 窗口最左边的字符离开窗口：x = x & ((1 << 20) - 1)，由于我们只考虑x的低20位比特，需要将其余位置零，即与上 (1 << 20) - 1。

```JAVA
class Solution {
    //这里必须是Character，否则和后面的s.charAt不匹配
    HashMap<Character, Integer> mapDNA = new HashMap<>(){{
        put('A', 0);
        put('T', 1);
        put('C', 2);
        put('G', 3);
    }};//注意！是0，1，2，3不是1，2，3，4
    public List<String> findRepeatedDnaSequences(String s) {
        HashMap<Integer, Integer> map = new HashMap<>();
        List<String> res = new ArrayList<>();
        int pattern = 0;
        if(s.length() <= 10) return res;//这里不加这个会导致下面的循环数组越界
        for(int i = 0; i < 9; i++){
            pattern = (pattern << 2) | mapDNA.get(s.charAt(i)); 
        }
        for(int i = 0; i <= s.length() - 10; i++){
            pattern = ((pattern << 2) | mapDNA.get(s.charAt(i + 9))) & ((1 << 20) - 1);
            map.put(pattern, map.getOrDefault(pattern, 0) + 1);
            if(map.get(pattern) == 2) {
                res.add(s.substring(i, i + 10));
            }
        }
        return res;
    }
}
//建议把10抽象成一个变量
```

**注意！！！**

我最后找来找去才发现最后一个bug是因为我没有给1 << 20加括号！气死我了，搞了一上午，居然是因为运算优先级。。。移位运算的优先级好低啊

**但是**，这么做的执行用时表现很差，最后我又看了另一个题解

https://leetcode-cn.com/problems/repeated-dna-sequences/solution/gong-shui-san-xie-yi-ti-shuang-jie-hua-d-30pg/

> 具体做法为，我们使用一个与字符串 s 等长的哈希数组 h[]，以及次方数组 p[]。
>
> 由字符串预处理得到这样的哈希数组和次方数组复杂度为 O(n)。当我们需要计算子串 s[i...j] 的哈希值，只需要利用前缀和思想 h[j] - h[i - 1] * p[j - i + 1] 即可在 O(1) 时间内得出哈希值（与子串长度无关）。
>
> 到这里，还有一个小小的细节需要注意：如果我们期望做到严格 O(n)，进行计数的「哈希表」就不能是以 String 作为 key，只能使用 Integer（也就是 hash 结果本身）作为 key。因为 Java 中的 String 的 hashCode 实现是会对字符串进行遍历的，这样哈希计数过程仍与长度有关，而 Integer 的 hashCode 就是该值本身，这是与长度无关的。
>

```java
class Solution {
    int N = (int)1e5+10, P = 131313;
    int[] h = new int[N], p = new int[N];
    public List<String> findRepeatedDnaSequences(String s) {
        int n = s.length();
        List<String> ans = new ArrayList<>();
        p[0] = 1;
        for (int i = 1; i <= n; i++) {
            h[i] = h[i - 1] * P + s.charAt(i - 1);
            p[i] = p[i - 1] * P;
        }
        Map<Integer, Integer> map = new HashMap<>();
        for (int i = 1; i + 10 - 1 <= n; i++) {
            int j = i + 10 - 1;
            int hash = h[j] - h[i - 1] * p[j - i + 1];
            int cnt = map.getOrDefault(hash, 0);
            if (cnt == 1) ans.add(s.substring(i - 1, i + 10 - 1));
            map.put(hash, cnt + 1);
        }
        return ans;
    }
}
```

上面这个代码的耗时就特别少，但难懂。

**于是**，我又去看了另一个题解，https://leetcode-cn.com/problems/repeated-dna-sequences/solution/tong-ge-lai-shua-ti-la-yi-ti-liang-jie-h-9lr9/

这个题解的写法和官方题解的思路几乎一样，但是耗时和内存都更少，太神奇了

```java
class Solution {

    // 把ACGT四个字符映射到2位的数字
    static int[] MASK_MAP = new int[26];
    static {
        MASK_MAP['A' - 'A'] = 0;
        MASK_MAP['C' - 'A'] = 1;
        MASK_MAP['G' - 'A'] = 2;
        MASK_MAP['T' - 'A'] = 3;
    }

    public List<String> findRepeatedDnaSequences(String s) {
        int n = s.length();
        List<String> ans = new ArrayList<>();
        if (n <= 10) {
            return ans;
        }

        // 记录每个hash出现的次数
        int[] map = new int[1 << 20];
        int hash = 0;
        for (int i = 0; i < 10; i++) {
            // 每2位一个字符
            hash = hash << 2 | MASK_MAP[s.charAt(i) - 'A'];
        }
        map[hash]++;

        for (int i = 1; i <= n - 10; i++) {
            // & 0xfffff 表示打掉最高位的2位
            hash = (hash << 2 | MASK_MAP[s.charAt(i + 10 - 1) - 'A']) & 0xfffff;
            map[hash]++;
            // 因为不存在hash冲突，所以可以直接使用
            if (map[hash] == 2) {
                ans.add(s.substring(i, i + 10));
            }
        }

        return ans;
    }
}
```

仔细看了下，发现是他把map全都用数组来做了，因为所有的子串对应的数字范围在1<<20以内，所以可以直接用一个长度为1<<20的数组来存。前面的ATCG对应数字的map也可以用数组来表示。数组比hashmap要快很多



#### 10.9 352 将数据流变成多个不相交区间（TreeMap）

给你一个由非负整数 a1, a2, ..., an 组成的数据流输入，请你将到目前为止看到的数字总结为不相交的区间列表。

实现 SummaryRanges 类：

SummaryRanges() 使用一个空数据流初始化对象。
void addNum(int val) 向数据流中加入整数 val 。
int[][] getIntervals() 以不相交区间 [starti, endi] 的列表形式返回对数据流中整数的总结。


示例：

```
输入：
["SummaryRanges", "addNum", "getIntervals", "addNum", "getIntervals", "addNum", "getIntervals", "addNum", "getIntervals", "addNum", "getIntervals"]
[[], [1], [], [3], [], [7], [], [2], [], [6], []]
输出：
[null, null, [[1, 1]], null, [[1, 1], [3, 3]], null, [[1, 1], [3, 3], [7, 7]], null, [[1, 3], [7, 7]], null, [[1, 3], [6, 7]]]

解释：
SummaryRanges summaryRanges = new SummaryRanges();
summaryRanges.addNum(1);      // arr = [1]
summaryRanges.getIntervals(); // 返回 [[1, 1]]
summaryRanges.addNum(3);      // arr = [1, 3]
summaryRanges.getIntervals(); // 返回 [[1, 1], [3, 3]]
summaryRanges.addNum(7);      // arr = [1, 3, 7]
summaryRanges.getIntervals(); // 返回 [[1, 1], [3, 3], [7, 7]]
summaryRanges.addNum(2);      // arr = [1, 2, 3, 7]
summaryRanges.getIntervals(); // 返回 [[1, 3], [7, 7]]
summaryRanges.addNum(6);      // arr = [1, 2, 3, 6, 7]
summaryRanges.getIntervals(); // 返回 [[1, 3], [6, 7]]
```

说实话看完示例我完全没明白，只好看了题解。因为我当时觉得[1,1] [2,2] [3,3]就是三个不相交的区间，没有想到这道题里的输入就全是整数，我这么想的话这题就不用做了。

所以应该理解为[1,1]和[2,2]是连在一起的，应该变成[1,2]这样的区间

这道题另一个比较难想的是用来存的数据结构，题解用了TreeMap，有序映射，来维护区间

题解说得很好，直接看题解吧

https://leetcode-cn.com/problems/data-stream-as-disjoint-intervals/solution/jiang-shu-ju-liu-bian-wei-duo-ge-bu-xian-hm1r/

```java
class SummaryRanges {
    TreeMap<Integer, Integer> map;
    public SummaryRanges() {
        map = new TreeMap<Integer, Integer>();
    }
    
    public void addNum(int val) {
        Map.Entry<Integer, Integer> interval0 = map.floorEntry(val);
        Map.Entry<Integer, Integer> interval1 = map.ceilingEntry(val + 1);
        if(interval0 != null && interval0.getKey() <= val && interval0.getValue() >= val){
            return;
        }
        else if (interval0 != null && interval0.getValue() + 1 == val && interval1 != null && interval1.getKey() == val + 1) {
            int left = interval0.getKey(), right = interval1.getValue();
            map.remove(interval0.getKey());
            map.remove(interval1.getKey());
            map.put(left, right);
        }
        else if(interval0 != null && interval0.getValue() + 1 == val && (interval1 == null || interval1.getKey() > val + 1)) {
            int left = interval0.getKey(), right = val;
            map.remove(interval0.getKey());
            map.put(left, right);
        }
        else if((interval0 == null || interval0.getValue() + 1 < val) && interval1 != null && interval1.getKey() == val + 1) {
            int left = val, right = interval1.getValue();
            map.remove(interval1.getKey());
            map.put(left, right);
        }
        else {
            map.put(val, val);
        }
    }
    
    public int[][] getIntervals() {
        int size = map.size();
        int[][] res = new int[size][2];
        int index = 0;
        for(Map.Entry<Integer, Integer> entry : map.entrySet()){
            res[index][0] = entry.getKey();
            res[index][1] = entry.getValue();
            index++;
        }
        return res;
    }
}

/**
 * Your SummaryRanges object will be instantiated and called as such:
 * SummaryRanges obj = new SummaryRanges();
 * obj.addNum(val);
 * int[][] param_2 = obj.getIntervals();
 */
```



#### 10.10 441 排列硬币（难想的二分）

你总共有 n 枚硬币，并计划将它们按阶梯状排列。对于一个由 k 行组成的阶梯，其第 i 行必须正好有 i 枚硬币。阶梯的最后一行 可能 是不完整的。

给你一个数字 n ，计算并返回可形成 完整阶梯行 的总行数。

**首先**，这道题配的图是不对的，别理它

这道题可以理解为求一个最大的k使得`(1 + k) * k / 2 <= n`

我觉得很难想到可以用二分来做，二分的左边界为1，右边界为n

看了好几种题解的二分，都觉得有点理解不来，摸索了自己的做法

```java
class Solution {
    public int arrangeCoins(int n) {
        long left = 1, right = n;
        while(left < right - 1){
            long mid = left + (right - left) / 2;
            long total = mid * (mid + 1) / 2;
            if(n >= total){
                left = mid;
            }
            else right = mid;
        }
        return (int)left;
    }
}
```

我的做法是，找一个left和right，他们满足

+ left * (left + 1) / 2 <= n
+ right * (right + 1) / 2 > n
+ left + 1 = right

这就能保证求出的left是最大的k

二分查找很难的几个地方是，while里的条件，left和right的赋值，最好是多代入几个例子试试

**注意**，代码里的total变量可能会数组越界，要用long来存，而且不能mid是int去做乘法然后再赋值给long，那样就来不及了，倒是可以把n >= total改写成(long)n >= (long)mid * (mid + 1) / 2

**第二种做法**：解方程

设(x + 1) * x / 2 = n，解出x的值，这时候x不一定为整数，向下取整就是答案了

```java
class Solution {
    public int arrangeCoins(int n) {
        return (int) ((Math.sqrt((long) 8 * n + 1) - 1) / 2);
    }
}
```

时间几乎一样



#### 10.11 273 整数转英文表示

将非负整数 num 转换为其对应的英文表示。

示例 1：

```
输入：num = 123
输出："One Hundred Twenty Three"
```

示例 2：

```
输入：num = 12345
输出："Twelve Thousand Three Hundred Forty Five"
```

示例 3：

```
输入：num = 1234567
输出："One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven"
```

示例 4：

```
输入：num = 1234567891
输出："One Billion Two Hundred Thirty Four Million Five Hundred Sixty Seven Thousand Eight Hundred Ninety One"
```


提示：

+ 0 <= num <= 231 - 1

```java
class Solution {
    String[] nums_1 = {"", "One", "Two", "Three", "Four", "Five", "Six", "Seven", "Eight", "Nine"};
    String[] nums_2 = {"", "", "Twenty", "Thirty", "Forty", "Fifty", "Sixty", "Seventy", "Eighty", "Ninety"};
    String[] nums_1x = {"Ten", "Eleven", "Twelve", "Thirteen", "Fourteen", "Fifteen", "Sixteen", "Seventeen", "Eighteen", "Nineteen"};
    public String numberToWords(int num) {
        if (num == 0) return "Zero"; // 注意是返回zero不是0
        ArrayList<String> list = new ArrayList<>();
        int[] stages = new int[4];
        int i = 0;
        while(num != 0){
            stages[i] = num % 1000;
            num /= 1000;
            i++;
        }
        String[] stage_name = {"", "Thousand", "Million", "Billion"};
        for(i = 3; i >= 0; i--){
            if(stages[i] != 0){
                list.add(numberToWordsUnder1000(stages[i]));
                list.add(stage_name[i]);
            }
        }
        return String.join(" ", list).trim(); // 注意这里最后会多一个空格，要删掉

    }
    private String numberToWordsUnder1000(int num) {
        ArrayList<String> list = new ArrayList<>();
        int[] stages = new int[3];
        int i = 0;
        while(num != 0){
            stages[i] = num % 10;
            num /= 10;
            i++;
        }    
        StringBuilder strb = new StringBuilder();
        if(stages[2] != 0) {
            list.add(nums_1[stages[2]]);
            list.add("Hundred");
        }
        if(stages[1] == 1) {
            list.add(nums_1x[stages[0]]);
        }
        else {
            if(stages[1] != 0) {
                list.add(nums_2[stages[1]]);
            }
            if(stages[0] != 0) {
                list.add(nums_1[stages[0]]);
            }
        }
        return String.join(" ", list);
    }
}
```



#### 10.12 



#### 10.13 412 Fizz Buzz

给你一个整数 n ，找出从 1 到 n 各个整数的 Fizz Buzz 表示，并用字符串数组 answer（下标从 1 开始）返回结果，其中：

```
answer[i] == "FizzBuzz" 如果 i 同时是 3 和 5 的倍数。
answer[i] == "Fizz" 如果 i 是 3 的倍数。
answer[i] == "Buzz" 如果 i 是 5 的倍数。
answer[i] == i 如果上述条件全不满足。
```

**示例 1：**

```
输入：n = 3
输出：["1","2","Fizz"]
```

```java
class Solution {
    public List<String> fizzBuzz(int n) {
        List<String> list = new ArrayList<>();
        for(int i = 1; i <= n; i++){
            if(i % 15 == 0){
                list.add("FizzBuzz");
            }
            else if(i % 3 == 0){
                list.add("Fizz");
            }
            else if(i % 5 == 0){
                list.add("Buzz");
            }
            else{
                list.add(String.valueOf(i));
            }
        }
        return list;
    }
}
```



#### 10.14 剑指offer 2 069 山峰数组的顶部

符合下列属性的数组 arr 称为 山峰数组（山脉数组） ：

```
arr.length >= 3
存在 i（0 < i < arr.length - 1）使得：
arr[0] < arr[1] < ... arr[i-1] < arr[i]
arr[i] > arr[i+1] > ... > arr[arr.length - 1]
给定由整数组成的山峰数组 arr ，返回任何满足 arr[0] < arr[1] < ... arr[i - 1] < arr[i] > arr[i + 1] > ... > arr[arr.length - 1] 的下标 i ，即山峰顶部。
```

 提示：

```
3 <= arr.length <= 104
0 <= arr[i] <= 106
题目数据保证 arr 是一个山脉数组
```


进阶：很容易想到时间复杂度 O(n) 的解决方案，你可以设计一个 O(log(n)) 的解决方案吗？

```java
class Solution {
    public int peakIndexInMountainArray(int[] arr) {
        int left = 0, right = arr.length;
        while(left < right){
            int mid = left + (right - left) / 2;
            if (arr[mid] < arr[mid + 1]) left = mid + 1;
            else if (arr[mid] < arr[mid - 1]) right = mid - 1;
            else return mid;
        }
        return left;
    }
}
```



#### 10.15 38 外观数列

给定一个正整数 n ，输出外观数列的第 n 项。

「外观数列」是一个整数序列，从数字 1 开始，序列中的每一项都是对前一项的描述。

你可以将其视作是由递归公式定义的数字字符串序列：

```
countAndSay(1) = "1"

countAndSay(n) 是对 countAndSay(n-1) 的描述，然后转换成另一个数字字符串。

```

前五项如下：

```
1.     1
2.     11
3.     21
4.     1211
5.     111221
       第一项是数字 1 
       描述前一项，这个数是 1 即 “ 一 个 1 ”，记作 "11"
       描述前一项，这个数是 11 即 “ 二 个 1 ” ，记作 "21"
       描述前一项，这个数是 21 即 “ 一 个 2 + 一 个 1 ” ，记作 "1211"
       描述前一项，这个数是 1211 即 “ 一 个 1 + 一 个 2 + 二 个 1 ” ，记作 "111221"
```

要 描述 一个数字字符串，首先要将字符串分割为 最小 数量的组，每个组都由连续的最多 相同字符 组成。然后对于每个组，先描述字符的数量，然后描述字符，形成一个描述组。要将描述转换为数字字符串，先将每组中的字符数量用数字替换，再将所有描述组连接起来。

```java
class Solution {
    public String countAndSay(int n) {
        if(n == 1) return "1";
        String pre = countAndSay(n - 1);
        StringBuilder res = new StringBuilder();
        int count = 1;
        char cur = pre.charAt(0);
        for(int i = 1; i < pre.length(); i++){
            if(pre.charAt(i) == pre.charAt(i - 1)){
                count++;
            }
            else{
                res.append(String.valueOf(count));
                res.append(cur);
                cur = pre.charAt(i);
                count = 1;
            }
        }
        res.append(String.valueOf(count));
        res.append(cur);
        return res.toString();
    }
}
```



#### 10.16 282 给表达式添加运算符

给定一个仅包含数字 0-9 的字符串 num 和一个目标值整数 target ，在 num 的数字之间添加 二元 运算符（不是一元）+、- 或 * ，返回所有能够得到目标值的表达式。

**示例 1:**

```
输入: num = "123", target = 6
输出: ["1+2+3", "1*2*3"] 
```

**注意** 可以不添加运算符

**示例 3:**

```
输入: num = "105", target = 5
输出: ["1*0+5","10-5"]
```

看了题解才做出来的，这道题看起来很吓人，但想通了其实也还好。一开始不敢去把所有的情况都算出来，总觉得可以dp之类的，也是没有写出来的原因

比较难想的是for循环内的部分，其实是分两个方向，一个是不添加运算符计算当前划分的值，一个是在当前划分后添加运算符，递归dfs

```java
class Solution {
    List<String> res = new ArrayList<>();
    int target;
    int len;
    public List<String> addOperators(String num, int target) {
        this.target = target;
        this.len = num.length();
        dfs(num, 0, 0, 0, "");
        return res;
    }
    public void dfs(String num, int start, long pre, long sum, String prefix){
        if(start == len){
            if(sum == target){
                res.add(prefix);
            }
            return;
        }
        long cur = 0;
        for(int i = start; i < len; i++){
            if(num.charAt(start) == '0' && i != start) break;
            cur = cur * 10 + (num.charAt(i) - '0');
            if(start != 0){
                dfs(num, i + 1, cur, sum + cur, prefix + "+" + cur);
                dfs(num, i + 1, -cur, sum - cur, prefix + "-" + cur);
                dfs(num, i + 1, pre * cur, sum - pre + pre * cur, prefix + "*" + cur);
            }
            else{
                dfs(num, i + 1, cur, cur, "" + cur);
            }
        }
    }
}
```



#### 10.17 230 二叉搜索树中第k小的元素

给定一个二叉搜索树的根节点 `root` ，和一个整数 `k` ，请你设计一个算法查找其中第 `k` 个最小元素（从 1 开始计数）。

中序遍历+全局变量

```java
class Solution {
    int count = 0;
    int k;
    int res = 0;
    public int kthSmallest(TreeNode root, int k) {
        this.k = k;
        inorder(root);
        return res;
    }
    public void inorder(TreeNode root){
        if(root.left != null) inorder(root.left);
        count++;
        if(count == k) res = root.val;
        if(root.right != null) inorder(root.right);
    }
}
```



#### 10.18 476 数字的补数

给你一个 **正** 整数 `num` ，输出它的补数。补数是对该数的二进制表示取反。

示例 1：

```
输入：num = 5
输出：2
解释：5 的二进制表示为 101（没有前导零位），其补数为 010。所以你需要输出 2 。
```

示例 2：

```
输入：num = 1
输出：0
解释：1 的二进制表示为 1（没有前导零位），其补数为 0。所以你需要输出 0 。
```


提示：

+ 给定的整数 num 保证在 32 位带符号整数的范围内。
+ num >= 1
+ 你可以假定二进制数不包含前导零位。

位运算简单题。不能直接按位取反，因为它要的是不包含前导零的二进制数的按位取反，所以得先找到num的二进制表示的第一个非0位，把这一位前面的所有位在结果中都置0（其实这一位取反后也是0）

num:    000101

mask:   111100

~mask: 000011

~num:   111010 （要想办法把前面的1都置0）

(~num) & (~mask)  就可以了

**注意** &运算的优先级比==低，所以 `while (mask & num == 0)`会报错，要加括号 `while ((mask & num) == 0)`

```java
class Solution {
    public int findComplement(int num) {
        int mask = 1 << 31;
        while ((mask & num) == 0){
            mask = mask >> 1;
        }
        mask = ~mask;
        num = ~num;
        num = num & mask;
        return num;
    }
}
```



#### 10.19 



#### 10.20 453 最小操作次数使数组元素相等（记住就好

给你一个长度为 `n` 的整数数组，每次操作将会使 `n - 1` 个元素增加 `1` 。返回让数组所有元素相等的最小操作次数。

一开始我直接奔着解函数去了，做不出来看了题解才知道，应该把n-1个元素加1理解成1个元素减一，然后就很简单了，只需要所有元素都减小到和最小的元素相等即可

```java
class Solution {
    public int minMoves(int[] nums) {
        int min = nums[0];
        int len = nums.length;
        for(int i = 1; i < len; i++){
            min = Math.min(min, nums[i]);
        }
        int res = 0;
        for(int i = 0; i < len; i++){
            res += nums[i] - min;
        }
        return res;
    }
}
```



#### 10.21 66 加一

给定一个由 整数 组成的 非空 数组所表示的非负整数，在该数的基础上加一。

最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。

你可以假设除了整数 0 之外，这个整数不会以零开头。

```java
class Solution {
    public int[] plusOne(int[] digits) {
        for(int i = digits.length - 1; i >= 0; i--){
            if(digits[i] != 9){
                digits[i]++;
                break;
            }
            else{
                digits[i] = 0;
            }
        }
        
        if(digits[0] == 0){
            int[] res = new int[digits.length + 1];
            res[0] = 1;
            // 如果进位一直进到第一位，说明原来是999这种，加一一定是首位为1，后面全是0，所以不需要再搬运
            // for(int i = 1; i < res.length; i++){
            //     res[i] = digits[i - 1];
            // }
            return res;
        }
        else return digits;
    }
}
```



#### 10.22 229 求众数（有点难想，记住吧

给定一个大小为 *n* 的整数数组，找出其中所有出现超过 `⌊ n/3 ⌋` 次的元素。

尝试设计时间复杂度为 O(n)、空间复杂度为 O(1)的算法解决此问题。

有点绕，需要参考题解，做过选出超过n/2次的元素，其实做法差不多，只不过之前是两个不同元素相抵消，现在是三个不同的元素相抵消

有点难想的是要怎么选择出三个元素（随便选），以及为什么这样做可以（因为如果大于三分之一，最终一定会留下来，可以反证），还有最后为什么需要检验（如果不检验可能会得到相同的两个元素，还有可能是最后的一个元素虽然只出现了几次但没有被抵消掉，或者数组里只有两种元素等等

```java
class Solution {
    public List<Integer> majorityElement(int[] nums) {
        int vote1 = 0, vote2 = 0;
        int element1 = 0, element2 = 0;
        for(int i = 0; i < nums.length; i++){
            if(vote1 > 0 && nums[i] == element1){
                vote1++;
            }
            else if(vote2 > 0 && nums[i] == element2){
                vote2++;
            }
            else if(vote1 == 0){
                element1 = nums[i];
                vote1++;
            }
            else if(vote2 == 0){
                element2 = nums[i];
                vote2++;
            }
            else{
                vote2--;
                vote1--;
            }
        }
        int count1 = 0, count2 = 0;
        for(int i = 0; i < nums.length; i++){
            if(nums[i] == element1) count1++;
            else if(nums[i] == element2) count2++;
        }//要注意数组里只有一种或两种元素的情况，这里要用else if, 不是if
        List<Integer> res = new ArrayList<>();
        if(count1 > nums.length / 3) res.add(element1);
        if(count2 > nums.length / 3) res.add(element2);
        return res;
    }
}
```



#### 10.23 492 构造矩形

设计一个长度为 L 和宽度为 W 且满足以下要求的矩形的页面。要求：

```
1. 你设计的矩形页面必须等于给定的目标面积。

2. 宽度 W 不应大于长度 L，换言之，要求 L >= W 。

3. 长度 L 和宽度 W 之间的差距应当尽可能小。
   你需要按顺序输出你设计的页面的长度 L 和宽度 W。
```

w <= sqrt(area)

L  >= sqrt(area)

从sqrt(area)开始找能被整除的w或者L就可以了

```java
class Solution {
    public int[] constructRectangle(int area) {
        int width = (int)Math.sqrt(area);
        while(width > 0){
            if(area % width == 0) break;
            width--;
        }
        return new int[]{area / width, width};
    }
}
```

