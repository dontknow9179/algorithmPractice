### 华为笔试

#### 3 无重复字符的最长子串（经典，双指针，滑动窗口）

给定一个字符串 `s` ，请你找出其中不含有重复字符的 **最长子串** 的长度。

```java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        if(s.length() == 0) return 0;
        if(s.length() == 1) return 1;
        int max = 1;
        int left = 0, right = 1;
        HashSet<Character> set = new HashSet<>();
        set.add(s.charAt(left));
        while(right < s.length()){
            while(set.contains(s.charAt(right))){
                set.remove(s.charAt(left));
                left++;
            }
            set.add(s.charAt(right));
            max = Math.max(max, right - left + 1);
            right++;
        }
        return max;
    }
}
```



#### 11 盛最多水的容器（没想到是双指针）

其实还有点贪心的感觉，一开始一直想单调栈之类的，后来看了题解才发现完全想错了

看懂怎么贪心之后就很好做了，一左一右两个指针，把比较小的那个往里移，不断计算并存储最大值就行了

```java
class Solution {
    public int maxArea(int[] height) {
        int left = 0, right = height.length - 1;
        int res = 0;
        while(left < right){
            res = Math.max(res, Math.min(height[left], height[right]) * (right - left));
            if(height[left] < height[right]){
                left++;
            }
            else{
                right--;
            }
        }
        return res;
    }
}
```



#### 17 电话号码的数字组合（backtracking经典）

给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。

给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。

```
输入：digits = "23"
输出：["ad","ae","af","bd","be","bf","cd","ce","cf"]
```

```
输入：digits = ""
输出：[]
```



```java
class Solution {
    private static final String[] KEYS = {"", "", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"};
    public List<String> letterCombinations(String digits) {
        List<String> list = new ArrayList<>();
        if(digits.length() == 0) return list; //记得判空
        StringBuilder strb = new StringBuilder();
        search(list, strb, digits, 0);
        return list;
    }
    //其实这个pos参数可以用strb.length()代替
    public void search(List<String> list, StringBuilder strb, String digits, int pos){
        if(pos == digits.length()){
            list.add(strb.toString());
            return;
        }
        String cur = KEYS[digits.charAt(pos) - '0'];
        for(int i = 0; i < cur.length(); i++){
            strb.append(cur.charAt(i));
            search(list, strb, digits, pos + 1);
            strb.deleteCharAt(strb.length() - 1);
        }
        return;
    }
}
```



#### 22 括号生成

数字 `n` 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 **有效的** 括号组合。

```
输入：n = 3
输出：["((()))","(()())","(())()","()(())","()()()"]
```

把问题想得太复杂了，看了题解才意识到其实是简单的**回溯**题

重点是：在加括号的时候保证每一步都是正确的，有两个规则

+ 当左括号的数量不超过规定数量时，可以加左括号
+ 当右括号的数量小于左括号时，可以加右括号

这样可以保证得到的最终结果一定是正确的组合，就不需要再验证一次是否有效

```java
class Solution {
    public List<String> generateParenthesis(int n) {
        List<String> result = new ArrayList<>();
        StringBuilder current = new StringBuilder();
        generateParenthesis(current, 0, 0, n, result);
        return result;
    }
    public void generateParenthesis(StringBuilder current, int leftCount, int rightCount, int max, List<String> result){
        if (current.length() == max * 2){
            result.add(current.toString());
            return;
        }
        if (leftCount < max) {
            current.append("(");
            generateParenthesis(current, leftCount + 1, rightCount, max, result);
            current.deleteCharAt(current.length() - 1);
        }
        if (rightCount < leftCount) {
            current.append(")");
            generateParenthesis(current, leftCount, rightCount + 1, max, result);
            current.deleteCharAt(current.length() - 1);
        }
    }
}
```



#### 30 串联所有单词的子串

给定一个字符串 s 和一些 长度相同 的单词 words 。找出 s 中恰好可以由 words 中所有单词串联形成的子串的起始位置。

注意子串要与 words 中的单词完全匹配，中间不能有其他字符 ，但不需要考虑 words 中单词串联的顺序。

示例 1：

```
输入：s = "barfoothefoobarman", words = ["foo","bar"]
输出：[0,9]
解释：
从索引 0 和 9 开始的子串分别是 "barfoo" 和 "foobar" 。
输出的顺序不重要, [9,0] 也是有效答案。
```

只要知道是用哈希表来做其实这道题就不难了，可惜我是看了题解才知道的

首先拿一个哈希表存words数组，key是string，value是次数，利用哈希表就可以对不考虑顺序的集合进行比较，不用set是因为words数组里面可能有单词出现了不止一次

接着遍历string，取出子串判断是否符合条件，我使用的策略是先判断一下这个子串的第一个单词是否符合要求，符合的话再取，然后就是为这个子串建立第二个哈希表，当第二个哈希表中某个单词出现的次数大于第一个哈希表时就break，还有当这个单词在第一个哈希表中不存在时break，就不需要其他条件了，像是次数不够的情况必然出现前两种之一。

```java
class Solution {
    public List<Integer> findSubstring(String s, String[] words) {
        Map<String, Integer> map1 = new HashMap<>();
        for(int i = 0; i < words.length; i++){
            map1.put(words[i], map1.getOrDefault(words[i], 0) + 1);
        }
        int len = words[0].length();
        int totalLen = len * words.length;
        List<Integer> res = new ArrayList<>();
        for(int i = 0; i <= s.length() - totalLen; i++){
            if(map1.containsKey(s.substring(i, i + len))){
                String cur = s.substring(i, i + totalLen);
                Map<String, Integer> map2 = new HashMap<>();
                int j;
                for(j = 0; j < totalLen; j = j + len){
                    String curSub = cur.substring(j, j + len);
                    if(map1.containsKey(curSub)){
                        map2.put(curSub, map2.getOrDefault(curSub, 0) + 1);
                        if(map1.get(curSub) < map2.get(curSub)) break;
                    }
                    else break;
                }
                if(j == totalLen) res.add(i);
            }
        }
        return res;
    }
}
```



#### 47 全排列二（回溯，类似第40题）

给定一个可包含重复数字的序列 `nums` ，**按任意顺序** 返回所有不重复的全排列。

和全排列一不同在数组中包含重复的数字

**示例 1：**

```
输入：nums = [1,1,2]
输出：
[[1,1,2],
 [1,2,1],
 [2,1,1]]
```

+ 要记得先给数组排序！这可以保证相同的数字放在一起

```java
class Solution {
    public List<List<Integer>> permuteUnique(int[] nums) {
        List<List<Integer>> res = new ArrayList<>();
        List<Integer> list = new ArrayList<>();
        boolean[] visited = new boolean[nums.length];
        Arrays.sort(nums);// 注意！
        dfs(res, list, visited, nums);
        return res;
    }
    void dfs(List<List<Integer>> res, List<Integer> list, boolean[] visited, int[] nums){
        if(list.size() == nums.length){
            res.add(new ArrayList<>(list));
            return;
        }
        for(int i = 0; i < nums.length; i++){
            if(!visited[i]){
                if(i > 0 && nums[i] == nums[i - 1] && !visited[i - 1]) continue;
                visited[i] = true;
                list.add(nums[i]);
                dfs(res, list, visited, nums);
                list.remove(list.size() - 1);
                visited[i] = false;
            }
        }
    }
}
```

用来保证list不重复的方法是：如果一个数字和前一个的值相同，就优先选前面的，也就是说，如果前面的数字visited为false，且值和当前的数字相同，那就不要选当前的数字



#### 78 子集（有点特别的回溯）

给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。

解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。

示例 1：

```
输入：nums = [1,2,3]
输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
```

示例 2：

```
输入：nums = [0]
输出：[[],[0]]
```


提示：

+ 1 <= nums.length <= 10
+ -10 <= nums[i] <= 10
+ nums 中的所有元素 互不相同

刚开始看到只想到了二进制的做法和比较傻的回溯，看了题解才意识到回溯也可以不用判断list长度是否等于nums的长度，只要用一个index判断是不是到了就行。我太傻了

大致思路是，对每个位置都有选或者不选两种，选的话就加入list，进入递归，递归结束后从list里移除，正好对应了不选，然后进入递归，递归结束之后也不用再从list里移除，因为本来就没加进去。

```java
class Solution {
    public List<List<Integer>> subsets(int[] nums) {
        List<List<Integer>> res = new ArrayList<>();
        List<Integer> list = new ArrayList<>();
        dfs(res, list, 0, nums);
        return res;
    }
    void dfs(List<List<Integer>> res, List<Integer> list, int cur, int[] nums){
        if(cur == nums.length){
            res.add(new ArrayList<Integer>(list));
            return;
        }
        list.add(nums[cur]);
        dfs(res, list, cur + 1, nums);
        list.remove(list.size() - 1);
        dfs(res, list, cur + 1, nums);
        // 这里和一般回溯不太一样，不需要再去掉一次了
    }
}
```



#### 79 单词搜索（回溯）

给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。

单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。

```java
class Solution {
    char[][] board;
    boolean[][] visited;
    String word;
    int[][] directions = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
    public boolean exist(char[][] board, String word) {
        // if(board.length == 0 || word.length() == 0)
        this.board = board;
        this.word = word;
        this.visited = new boolean[board.length][board[0].length];
        for(int i = 0; i < board.length; i++){
            for(int j = 0; j < board[0].length; j++){
                if(dfs(0, i, j)) return true;
            }
        }
        return false;
    }
    boolean dfs(int index, int i, int j){
        if(index == word.length()) return true;
        if(!isValid(i, j) || board[i][j] != word.charAt(index)) return false;
        visited[i][j] = true;
        for(int[] direction : directions){
            if(dfs(index + 1, i + direction[0], j + direction[1])) return true;
        }
        visited[i][j] = false;
        return false;
    } 
    boolean isValid(int i, int j){
        // 记得判断位置是否越界，是否已经访问过
        if(i < 0 || j < 0 || i >= board.length || j >= board[0].length || visited[i][j]) return false;
        else return true;
    }
}


```



#### 90 子集二（回溯，含重复元素）

给你一个整数数组 nums ，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。

解集 不能 包含重复的子集。返回的解集中，子集可以按 任意顺序 排列。

示例 1：

```
输入：nums = [1,2,2]
输出：[[],[1],[1,2],[1,2,2],[2],[2,2]]
```

示例 2：

```
输入：nums = [0]
输出：[[],[0]]
```


提示：

+ 1 <= nums.length <= 10
+ -10 <= nums[i] <= 10

一开始用的是list.contains来判断前面有没有（因为不想开新的数组），当前的要不要放。结果没法处理类似[1,1,1]这种情况。然后我就怀疑是list.contains这个方法的问题。后来实验证明了不是它的问题。它是用equals比较的，比如说[1,1,1]，当list里有第一个1的时候，你问他有没有第二个1，会返回true，这时候如果正好在第三个位置，就会以为第二个已经加了，然后把第三个也放进去，其实不行。

所以我用了visited数组。题解用的是preVisited变量，更省

```java
class Solution {
    public List<List<Integer>> subsetsWithDup(int[] nums) {
        Arrays.sort(nums);
        List<List<Integer>> res = new ArrayList<>();
        List<Integer> list = new ArrayList<>();
        boolean[] visited = new boolean[nums.length];
        dfs(res, list, 0, nums, visited);
        return res;
    }
     void dfs(List<List<Integer>> res, List<Integer> list, int cur, int[] nums, boolean[] visited){
        if(cur == nums.length){
            res.add(new ArrayList<Integer>(list));
            return;
        }
        if(cur > 0 && nums[cur] == nums[cur - 1] && !visited[cur - 1]){}
        else{
            list.add(nums[cur]);
            visited[cur] = true;
            dfs(res, list, cur + 1, nums, visited);
            list.remove(list.size() - 1);
            visited[cur] = false;
        }
        dfs(res, list, cur + 1, nums, visited);
    }
}
```



#### 93 复原IP地址（回溯，不要怕）

有效 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 '.' 分隔。

例如："0.1.2.201" 和 "192.168.1.1" 是 有效 IP 地址，但是 "0.011.255.245"、"192.168.1.312" 和 "192.168@1.1" 是 无效 IP 地址。
给定一个只包含数字的字符串 s ，用以表示一个 IP 地址，返回所有可能的有效 IP 地址，这些地址可以通过在 s 中插入 '.' 来形成。你不能重新排序或删除 s 中的任何数字。你可以按 任何 顺序返回答案。

```java
class Solution {
    public List<String> restoreIpAddresses(String s) {
        List<String> res = new ArrayList<>();
        List<String> list = new ArrayList<>();
        dfs(res, s, 0, list);
        return res;
    }
    void dfs(List<String> res, String s, int index, List<String> list){
        if(index == s.length() && list.size() == 4){
            res.add(String.join(".", list));// 注意这里需要用双引号，否则报错
            return;
        }
        // 这里也需要判断是否不符合条件
        else if(index >= s.length() || list.size() >= 4) return;
		
        // 0比较特殊
        if(s.charAt(index) == '0'){
            list.add("0");
            dfs(res, s, index + 1, list);
            list.remove(list.size() - 1);
        }

        else{
            int sum = 0;
            for(int i = 0; i < 3; i++){
                if(index + i == s.length()) break; 
                // 注意这里要判断是否越界，可能最后剩不到3位了
                sum = sum * 10 + (s.charAt(index + i) - '0');
                if(sum <= 255){
                    list.add(s.substring(index, index + i + 1));
                    dfs(res, s, index + i + 1, list);
                    list.remove(list.size() - 1);
                }
            }
        }
    }
}
```



#### 117 填充每个节点的下一个右侧节点指针二（借助全局变量实现常量空间）

给定一个二叉树

```java
class Node {
    public int val;
    public Node left;
    public Node right;
    public Node next;

    public Node() {}
    
    public Node(int _val) {
        val = _val;
    }

    public Node(int _val, Node _left, Node _right, Node _next) {
        val = _val;
        left = _left;
        right = _right;
        next = _next;
    }
};
```

填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。

初始状态下，所有 next 指针都被设置为 NULL。

进阶：

你只能使用常量级额外空间。
使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。

这是比较简单的层次遍历做法：

```c++
class Solution {
public:
    Node* connect(Node* root) {
        if(!root) return root;
        queue<Node*> q;
        q.push(root);
        while(!q.empty()){
            int n = q.size();    
            for(int i = 0; i < n; i++){
                Node* cur = q.front();
                q.pop();
                if(i != n - 1) cur->next = q.front();
                
                if(cur->left) q.push(cur->left);
                if(cur->right) q.push(cur->right);
            }
        }
        return root;
    }
};
```

看了题解写的下面这种常量空间做法

start存当前行的第一个node。nextStart存下一行的start，last存前一个node用来把下一行连起来

只要用next连起来了，就不需要用queue来存每一行，只要存链表的头结点就行了

所以遍历当前链表时把下一行的节点连成链表，第一行只有根节点，相当于只有一个node的链表

```java
class Solution {
    Node nextStart, last;
    public Node connect(Node root) {
        if(root == null) return root;
        
        Node start = root;
        while(start != null){
            nextStart = null;
            last = null;
            // 遍历当前行
            for(Node p = start; p != null; p = p.next){
                if(p.left != null) handle(p.left);
                if(p.right != null) handle(p.right);
            }
            start = nextStart;
        }
        return root;
    }

    void handle(Node p){
        if(nextStart == null){
            nextStart = p;
        }
        if(last != null){
            last.next = p;
        }
        last = p;
    }
}
```



#### 130 被围绕的区域（DFS）

给你一个 `m x n` 的矩阵 `board` ，由若干字符 `'X'` 和 `'O'` ，找到所有被 `'X'` 围绕的区域，并将这些区域里所有的 `'O'` 用 `'X'` 填充。

做法类似200题，区别只是dfs的起点变成了矩阵的四个边，还有最后多处理一遍

大致思路是把不需要被X填充的O标记出来，剩下的O就是要被填充的

不会被填充的O都可以从四条边通过DFS找到

```java
class Solution {
    public void solve(char[][] board) {    
        int m = board.length;
        if(m == 0) return;
        int n = board[0].length;
        if(n == 0) return;

        for(int i = 0; i < m; i++){
            dfs(board, i, 0);
            dfs(board, i, n - 1);
        }

        for(int j = 1; j < n - 1; j++){
            dfs(board, 0, j);
            dfs(board, m - 1, j);
        }

        for(int i = 0; i < m; i++){
            for(int j = 0; j < n; j++){
                if(board[i][j] == 'A'){
                    board[i][j] = 'O';
                }
                else if(board[i][j] == 'O'){
                    board[i][j] = 'X';
                }
            }
        }
    }

    void dfs(char[][] board, int i, int j){
        if(i < 0 || i >= board.length || j < 0 || j >= board[0].length || board[i][j] != 'O') return;
        board[i][j] = 'A';
        dfs(board, i + 1, j);
        dfs(board, i - 1, j);
        dfs(board, i, j + 1);
        dfs(board, i, j - 1);
    }
}
```



#### 162 寻找峰值（想了好久的二分）

峰值元素是指其值严格大于左右相邻值的元素。

给你一个整数数组 nums，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 任何一个峰值 所在位置即可。

你可以假设 nums[-1] = nums[n] = -∞ 。

你必须实现时间复杂度为 O(log n) 的算法来解决此问题。

看到时间复杂度是log就知道要二分，画图分了7种情况，分类讨论处理low和high的赋值，循环终止条件是low==high

```java
class Solution {
    public int findPeakElement(int[] nums) {
        // 边界情况[],[1],[1,2,3],[3,2,1]
        if(nums.length == 1) return 0;
        if(nums.length > 1){
            if(nums[0] > nums[1]) return 0;
            if(nums[nums.length - 1] > nums[nums.length - 2]) return nums.length - 1;
        }
        int low = 0;
        int high = nums.length - 1;
        while(low < high){
            int mid = low + (high - low) / 2;
            if(mid > 0 && nums[mid] > nums[mid - 1]){
                low = mid;
            }
            if(mid < nums.length - 1 && nums[mid] > nums[mid + 1]){
                high = mid;
            }
            // 后面两个都必须加else
            else if(mid > 0 && nums[mid] < nums[mid - 1]){
                high = mid - 1;
            }
            else if(mid < nums.length - 1 && nums[mid] < nums[mid + 1]){
                low = mid + 1;
            }
        }
        return low;
    }
}
```

看了题解，大致思路和我一样，但是加了辅助函数，就可以不用操心数组越界的情况，这样需要讨论的情况就只有四种：峰值，谷值，低中高，高中低。其中谷值可以和低中高合并。

```java
class Solution {
    public int findPeakElement(int[] nums) {
        int n = nums.length;
        int left = 0, right = n - 1, ans = -1;
        while (left <= right) {
            int mid = (left + right) / 2;
            if (compare(nums, mid - 1, mid) < 0 && compare(nums, mid, mid + 1) > 0) {
                ans = mid;
                break;
            }
            if (compare(nums, mid, mid + 1) < 0) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        return ans;
    }

    // 辅助函数，输入下标 i，返回一个二元组 (0/1, nums[i])
    // 方便处理 nums[-1] 以及 nums[n] 的边界情况
    public int[] get(int[] nums, int idx) {
        if (idx == -1 || idx == nums.length) {
            return new int[]{0, 0};
        }
        return new int[]{1, nums[idx]};
    }

    public int compare(int[] nums, int idx1, int idx2) {
        int[] num1 = get(nums, idx1);
        int[] num2 = get(nums, idx2);
        if (num1[0] != num2[0]) {
            return num1[0] > num2[0] ? 1 : -1;
        }
        if (num1[1] == num2[1]) {
            return 0;
        }
        return num1[1] > num2[1] ? 1 : -1;
    }
}
```

最后！我参考题解的分类，写出了下面这个简洁的版本！

重点在于不用判断mid+1是否越界，因为mid不可能是high，mid可能是low，假如mid==high，那肯定先有low==high，那就退出循环了

```java
class Solution {
    public int findPeakElement(int[] nums) {
        // 边界情况[],[1],[1,2,3],[3,2,1]
        if(nums.length == 1) return 0;
        if(nums.length > 1){
            if(nums[0] > nums[1]) return 0;
            if(nums[nums.length - 1] > nums[nums.length - 2]) return nums.length - 1;
        }
        int low = 0;
        int high = nums.length - 1;
        while(low < high){
            int mid = low + (high - low) / 2;
            if(mid > 0 && nums[mid] > nums[mid - 1] && nums[mid] > nums[mid + 1]) return mid;
            if(nums[mid] > nums[mid + 1]) high = mid;// 可以改成high = mid - 1; 原因见“后续”
            if(nums[mid] < nums[mid + 1]) low = mid + 1;
        }
        return low;
    }
}
```

**后续**

我发现nums[mid] > nums[mid + 1]的时候，mid也不可能是low，如果mid==low，那会再更前面的特判里被处理掉，没有处理到就说明nums[low]<nums[low+1] && nums[high]<nums[high-1]，所以这个if语句里high可以等于mid-1不用担心越界



#### 200 岛屿数量（DFS）

给你一个由 '1'（陆地）和 '0'（水）组成的的二维网格，请你计算网格中岛屿的数量。

岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。

此外，你可以假设该网格的四条边均被水包围。

看题目觉得很难，看了题解才发现只是普通的DFS

主要的思路是在DFS的时候把连着的一块陆地从标记1改为标记2（题解里用的是0，都可以），计算可以有几次DFS，就说明有几个岛

```java
class Solution {
    public int numIslands(char[][] grid) {
        int count = 0;
        for(int i = 0; i < grid.length; i++){
            for(int j = 0; j < grid[0].length; j++){
                if(grid[i][j] == '1'){
                    count++;
                    dfs(grid, i, j);
                }
            }
        }
        return count;
    }
    void dfs(char[][] grid, int i, int j){
        if(i < 0 || j < 0 || i >= grid.length || j >= grid[0].length) return;
        if(grid[i][j] != '1') return;
        grid[i][j] = '2';
        dfs(grid, i + 1, j);
        dfs(grid, i - 1, j);
        dfs(grid, i, j + 1);
        dfs(grid, i, j - 1);
        return;
    }
}
```

[通用解法](https://leetcode-cn.com/problems/number-of-islands/solution/dao-yu-lei-wen-ti-de-tong-yong-jie-fa-dfs-bian-li-/)这个题解写得特别好，非常推荐



#### 207 课程表（BFS/DFS 拓扑排序）

你这个学期必须选修 numCourses 门课程，记为 0 到 numCourses - 1 。

在选修某些课程之前需要一些先修课程。 先修课程按数组 prerequisites 给出，其中 prerequisites[i] = [ai, bi] ，表示如果要学习课程 ai 则 必须 先学习课程  bi 。

例如，先修课程对 [0, 1] 表示：想要学习课程 0 ，你需要先完成课程 1 。
请你判断是否可能完成所有课程的学习？如果可以，返回 true ；否则，返回 false 。

示例 1：

```
输入：numCourses = 2, prerequisites = [[1,0]]
输出：true
解释：总共有 2 门课程。学习课程 1 之前，你需要完成课程 0 。这是可能的。
```

看了题解写的代码，用的是拓扑排序的思路，类似BFS

我觉得比较阻碍我写出来的是用一个List\<List\<Integer>>来存边的信息，以及用一个int数组来存每个点的入度。最后是用一个队列来存入度为0的点（之后我验证了，这里用队列或者栈都行，因为只要进来了，就都是入度为0。

主要逻辑就是，遍历入度为0的点，将它们所指向的点的入度减一，如果减一后等于0，就加入队列中。遍历时累计入度为0的点的个数，如果最后等于总的点的个数，就说明没有环。

**注意！**循环终止条件为队列为空。所以第一遍要先把入度为0的点加进队列里

```java
class Solution {
    public boolean canFinish(int numCourses, int[][] prerequisites) {
        Queue<Integer> queue = new LinkedList<>();
        // Stack<Integer> queue = new Stack<>();
        List<List<Integer>> edges = new ArrayList<>();
        int[] indegree = new int[numCourses];
        for(int i = 0; i < numCourses; i++){
            edges.add(new ArrayList<Integer>());
        }
        for(int i = 0; i < prerequisites.length; i++){
            indegree[prerequisites[i][0]]++;
            edges.get(prerequisites[i][1]).add(prerequisites[i][0]);
        }
        for(int i = 0; i < numCourses; i++){
            if(indegree[i] == 0) queue.add(i);
        }
        int visited = 0;
        while(!queue.isEmpty()){
            int i = queue.poll();
            // int i = queue.pop();
            visited++;
            for(int j = 0; j < edges.get(i).size(); j++){
                indegree[edges.get(i).get(j)]--;
                if(indegree[edges.get(i).get(j)] == 0) {
                    queue.add(edges.get(i).get(j));
                    // queue.push(edges.get(i).get(j));
                }
            }
        }
        return visited == numCourses;
    }
}
```

这是我参考210题解的DFS写法写的，没有真的用到栈，只用了一个int数组标记每个点的状态，当这个点已经在搜索中，却又被另一个点搜索时，就说明有环，当一个点的所有邻接点都访问完后，就把状态改为已完成，这种做法比BFS要快

```java
class Solution {
    // 存储有向图
    List<List<Integer>> edges;
    // 标记每个节点的状态：0=未搜索，1=搜索中，2=已完成
    int[] visited;

    public boolean canFinish(int numCourses, int[][] prerequisites) {
        edges = new ArrayList<List<Integer>>();
        for (int i = 0; i < numCourses; ++i) {
            edges.add(new ArrayList<Integer>());
        }
        visited = new int[numCourses];
        for (int[] info : prerequisites) {
            edges.get(info[1]).add(info[0]);
        }
        // 每次挑选一个「未搜索」的节点，开始进行深度优先搜索
        for (int i = 0; i < numCourses; ++i) {
            if (!dfs(i)) {
                return false;
            }
        }
        return true;
    }

    public boolean dfs(int u) {
        if(visited[u] == 2) return true;
        if(visited[u] == 1) return false;
        // 将节点标记为「搜索中」
        visited[u] = 1;
        // 搜索其相邻节点
        // 只要发现有环，立刻停止搜索
        for (int v: edges.get(u)) {
            if(!dfs(v)) return false;    
        }
        // 将节点标记为「已完成」
        visited[u] = 2;
        return true;
    }
}
```



#### 209 长度最小的子数组（滑动窗口）

给定一个含有 n 个正整数的数组和一个正整数 target 。

找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。

```java
class Solution {
    public int minSubArrayLen(int target, int[] nums) {
        int left = 0, right = 0;
        int sum = 0;
        int res = Integer.MAX_VALUE;
        while(right < nums.length){
            sum += nums[right];
            while(sum >= target){
                res = Math.min(res, right - left + 1);
                sum -= nums[left];
                left++;
            }
            right++;
        }
        return res == Integer.MAX_VALUE ? 0 : res;
    }
}
```



#### 210 课程表二（BFS/DFS 拓扑排序）

现在你总共有 numCourses 门课需要选，记为 0 到 numCourses - 1。给你一个数组 prerequisites ，其中 prerequisites[i] = [ai, bi] ，表示在选修课程 ai 前 必须 先选修 bi 。

例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示：[0,1] 。
返回你为了学完所有课程所安排的学习顺序。可能会有多个正确的顺序，你只要返回 任意一种 就可以了。如果不可能完成所有课程，返回 一个空数组 。

```java
class Solution {
    public int[] findOrder(int numCourses, int[][] prerequisites) {
        Queue<Integer> queue = new LinkedList<>();
        List<List<Integer>> edges = new ArrayList<>();
        int[] indegree = new int[numCourses];
        for(int i = 0; i < numCourses; i++){
            edges.add(new ArrayList<Integer>());
        }
        for(int i = 0; i < prerequisites.length; i++){
            indegree[prerequisites[i][0]]++;
            edges.get(prerequisites[i][1]).add(prerequisites[i][0]);
        }
        for(int i = 0; i < numCourses; i++){
            if(indegree[i] == 0) queue.add(i);
        }
        int visited = 0;
        int[] res = new int[numCourses];
        while(!queue.isEmpty()){
            int i = queue.poll();
            res[visited] = i;
            visited++;
            for(int j = 0; j < edges.get(i).size(); j++){
                indegree[edges.get(i).get(j)]--;
                if(indegree[edges.get(i).get(j)] == 0) queue.add(edges.get(i).get(j));
            }
        }
        return visited == numCourses ? res : new int[0];
    }
}
```

参考题解的DFS写法写的代码如下

```java
class Solution {
    // 存储有向图
    List<List<Integer>> edges;
    // 标记每个节点的状态：0=未搜索，1=搜索中，2=已完成
    int[] visited;
    // 用数组来模拟栈，下标 n-1 为栈底，0 为栈顶
    int[] result;
    // 栈下标
    int index;

    public int[] findOrder(int numCourses, int[][] prerequisites) {
        edges = new ArrayList<List<Integer>>();
        for (int i = 0; i < numCourses; ++i) {
            edges.add(new ArrayList<Integer>());
        }
        visited = new int[numCourses];
        result = new int[numCourses];
        index = numCourses - 1;
        for (int[] info : prerequisites) {
            edges.get(info[1]).add(info[0]);
        }
        // 每次挑选一个「未搜索」的节点，开始进行深度优先搜索
        for (int i = 0; i < numCourses; ++i) {
            if (!dfs(i)) {
                return new int[0];
            }
        }
        // 如果没有环，那么就有拓扑排序
        return result;
    }

    public boolean dfs(int u) {
        if(visited[u] == 2) return true;
        if(visited[u] == 1) return false;
        // 将节点标记为「搜索中」
        visited[u] = 1;
        // 搜索其相邻节点
        // 只要发现有环，立刻停止搜索
        for (int v: edges.get(u)) {
            if (!dfs(v)) {
                return false;
            }
        }
        // 将节点标记为「已完成」
        visited[u] = 2;
        // 将节点入栈
        result[index--] = u;
        return true;
    }
}
```



#### 239 滑动窗口最大值（单调双端队列）

给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。

返回滑动窗口中的最大值。

参考了[五分钟学算法](https://mp.weixin.qq.com/s?__biz=MzUyNjQxNjYyMg==&mid=2247498838&idx=2&sn=c10692783ae0bee1312ffe1aa7d10339&chksm=fa0d93d7cd7a1ac1ceff349bfe2a67770bdcebca3bd8a13c5148e6aacab087dbee8154cbeea8&scene=126&sessionid=1616233063&key=4764af25be59e44a2a6d0a22e84b56ef4f29cd5450586618381eda3dcc1a89ac4bc5c790ef342db8ed6bb61acafba342aa10f2ddac5900b381931c725a65f0db410c00813cad0ed142edc3df638b4c586d9a073685ba6c1f02a63c1f9e7c3e36cc53a2217df5d370a5a423bc947a7107213ecd9792c609729ee34dc8950465d8&ascene=1&uin=Mzg0Njg0NzU2&devicetype=Windows+10+x64&version=62090529&lang=zh_CN&exportkey=A%2BQKkwMXJve5HGlpk1VN8u0%3D&pass_ticket=R%2F0%2Fb2w4jP8VfyFlSRsubdTmnhgWNUHpUDtMa%2FGe957YH6%2BYbTc3O%2FLJjZZMGFnF&wx_header=0)里的图解写出下面的代码，这里用的是单调递减队列，**队列里存的是元素的下标，当队首的下标比窗口的左边界要小的时候，需要把队首移除**

```java
class Solution {
    public int[] maxSlidingWindow(int[] nums, int k) {
        int len = nums.length;
        int[] res = new int[len - k + 1];
        Deque<Integer> queue = new LinkedList<>();
        for(int i = 0; i < len; i++){
            while(!queue.isEmpty() && nums[queue.peekLast()] < nums[i]){
                queue.removeLast();
            }
            queue.addLast(i);
            if(i - queue.peek() >= k){
                queue.removeFirst();
            }
            if(i >= k - 1){
                res[i - k + 1] = nums[queue.peek()];
            }
        }
        return res;
    }
}
```

**注意**和剑指offer的59-1相同，但是代码复制过去却不行。

**原因** 剑指里输入的数组可能长度为0，需要增加一个判断，长度为零时返回[]



#### 300 最长递增子序列

给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。

子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。

基于二分查找的做法，有点贪心的思想。需要维护一个递增的list，遍历数组时，如果当前元素大于list最大值，则直接append，否则二分查找，找到它应该插入的位置，替代该位置的值

```java
class Solution {
    public int lengthOfLIS(int[] nums) {
        int len = nums.length;
        if(len < 2) return len;
        List<Integer> list = new ArrayList<>();
        list.add(nums[0]);
        for(int i = 1; i < len; i++){
            if(nums[i] > list.get(list.size() - 1)){
                list.add(nums[i]);
            }
            else{
                int index = binarySearch(list, nums[i]);
                list.set(index, nums[i]);
            }
        }
        return list.size();
    }
    int binarySearch(List<Integer> list, int target){
        int low = 0, high = list.size() - 1;
        while(low <= high){
            int mid = low + (high - low) / 2;
            if(list.get(mid) == target) return mid;
            if(list.get(mid) > target) high = mid - 1;
            else low = mid + 1;
        }
        return low;
    }
}
```



#### 353 贪吃蛇（双端队列）

请你设计一个 贪吃蛇游戏，该游戏将会在一个 屏幕尺寸 = 宽度 x 高度 的屏幕上运行。如果你不熟悉这个游戏，可以 点击这里 在线试玩。

起初时，蛇在左上角的 (0, 0) 位置，身体长度为 1 个单位。

你将会被给出一个数组形式的食物位置序列 food ，其中 food[i] = (ri, ci) 。当蛇吃到食物时，身子的长度会增加 1 个单位，得分也会 +1 。

食物不会同时出现，会按列表的顺序逐一显示在屏幕上。比方讲，第一个食物被蛇吃掉后，第二个食物才会出现。

当一个食物在屏幕上出现时，保证 不会 出现在被蛇身体占据的格子里。

如果蛇越界（与边界相撞）或者头与 移动后 的身体相撞（即，身长为 4 的蛇无法与自己相撞），游戏结束。

实现 SnakeGame 类：

SnakeGame(int width, int height, int[][] food) 初始化对象，屏幕大小为 height x width ，食物位置序列为 food
int move(String direction) 返回蛇在方向 direction 上移动后的得分。如果游戏结束，返回 -1 。

这道题其实就是模拟题，比较难的是怎么模拟蛇的移动，一开始想太复杂了，其实很简单

只要考虑蛇头和蛇尾就行，所以使用一个双端队列，如果没有碰到食物，就是在队尾去掉一个元素，在队头增加一个元素

每次移动可以分三种情况

+ 出界
+ 吃到食物，蛇尾不动，蛇头增加
+ 没吃到食物，蛇尾remove，蛇头add，要判断新增的蛇头是否已经在queue中，也就是是否和身体相撞

需要一些成员变量，其中queue里存的integer是row*width+column

```java
class SnakeGame {
    private int score, foodIndex, width, height;
    private int[][] food;
    private Deque<Integer> queue = new LinkedList<>();
    public SnakeGame(int width, int height, int[][] food) {
        this.food = food; 
        this.score = 0;
        this.width = width;
        this.height = height;
        this.foodIndex = 0;
        queue.add(0);
    }
    
    public int move(String direction) {
        int head = queue.peek();
        int row = head / width;
        int column = head % width;
        if(direction.equals("R")){
            column++;
        }
        else if(direction.equals("L")){
            column--;
        }
        else if(direction.equals("U")){
            row--;
        }
        else{
            row++;
        }
        if(row < 0 || row >= height || column < 0 || column >= width){
            return -1;
        }
        head = row * width + column;
        if(foodIndex < food.length && food[foodIndex][0] == row && food[foodIndex][1] == column){
            foodIndex++;
            queue.addFirst(head);
            return ++score;
        }

        queue.pollLast();
        if(queue.contains(head)){
            return -1;
        }
        queue.addFirst(head);
        return score;
    }
}

/**
 * Your SnakeGame object will be instantiated and called as such:
 * SnakeGame obj = new SnakeGame(width, height, food);
 * int param_1 = obj.move(direction);
 */
```



#### 438 找到字符串中所有字母异位词（滑动窗口）

给定两个字符串 s 和 p，找到 s 中所有 p 的 异位词 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。

异位词 指由相同字母重排列形成的字符串（包括相同的字符串）。 

示例 1:

```
输入: s = "cbaebabacd", p = "abc"
输出: [0,6]
解释:
起始索引等于 0 的子串是 "cba", 它是 "abc" 的异位词。
起始索引等于 6 的子串是 "bac", 它是 "abc" 的异位词。
```

**提示:**

- `1 <= s.length, p.length <= 3 * 104`
- `s` 和 `p` 仅包含小写字母

```java
class Solution {
    public List<Integer> findAnagrams(String s, String p) {
        int[] countP = new int[26];
        int[] countS = new int[26];
        List<Integer> res = new ArrayList<>();
        for(int i = 0; i < p.length(); i++){
            char c = p.charAt(i);
            countP[c - 'a']++;
        }
        int left = 0, right = 0;
        while(right < s.length()){
            char cur = s.charAt(right);
            countS[cur - 'a']++;
            if(right - left + 1 == p.length()){
                if(equal(countS, countP)){
                    res.add(left);
                }
                char del = s.charAt(left);
                countS[del - 'a']--;
                left++;
            }
            right++;
        }
        return res;
    }
    boolean equal(int[] nums1, int[] nums2){
        for(int i = 0; i < nums2.length; i++){
            if(nums1[i] != nums2[i]) return false;
        }
        return true;
    }
}
```

主要的点是用一个数组来记录每个字母出现的次数，如果用map开销会比较大



#### 484 寻找排列（找规律，贪心）

由范围 [1,n] 内所有整数组成的 n 个整数的排列 perm 可以表示为长度为 n - 1 的字符串 s ，其中:

如果 perm[i] < perm[i + 1] ，那么 s[i] == ' i '
如果 perm[i] > perm[i + 1] ，那么 s[i] == 'D' 。
给定一个字符串 s ，重构字典序上最小的排列 perm 并返回它。

示例 1：

```
输入： s = "I"
输出： [1,2]
解释： [1,2] 是唯一合法的可以生成秘密签名 "I" 的特定串，数字 1 和 2 构成递增关系。
```

示例 2：

```
输入： s = "DI"
输出： [2,1,3]
解释： [2,1,3] 和 [3,1,2] 可以生成秘密签名 "DI"，
但是由于我们要找字典序最小的排列，因此你需要输出 [2,1,3]。
```


提示：

1 <= s.length <= 105
s[i] 只会包含字符 'D' 和 'I'。

多举几个例子就可以找到规律啦，一开始先假设全是I，答案就是顺序的12345...如果遇到D，就需要reverse，比如12变成21，如果是两个D，就是123变成321，所以说遇到几个D，就翻转（几加一）个数字

```java
class Solution {
    public int[] findPermutation(String s) {
        int[] res = new int[s.length() + 1];
        for(int i = 0; i < res.length; i++){
            res[i] = i + 1;
        }
        
        for(int i = 0; i < s.length(); i++){
            if(s.charAt(i) == 'D'){
                int j = i;
                while(j < s.length() && s.charAt(j) == 'D'){
                    j++;
                }
                int left = i;
                int right = j;
                int tmp = 0;
                while(left < right){
                    tmp = res[left];
                    res[left] = res[right];
                    res[right] = tmp;
                    left++;
                    right--;
                }
                i = j;
            }
            
        }
        return res;
    }
}
```



#### 547 省份数量（DFS）

有 n 个城市，其中一些彼此相连，另一些没有相连。如果城市 a 与城市 b 直接相连，且城市 b 与城市 c 直接相连，那么城市 a 与城市 c 间接相连。

省份 是一组直接或间接相连的城市，组内不含其他没有相连的城市。

给你一个 n x n 的矩阵 isConnected ，其中 isConnected\[i][j] = 1 表示第 i 个城市和第 j 个城市直接相连，而 isConnected\[i][j] = 0 表示二者不直接相连。

返回矩阵中 省份 的数量。

```java
class Solution {
    public int findCircleNum(int[][] isConnected) {
        int n = isConnected.length;
        boolean[] cities = new boolean[n];
        int count = 0;
        for(int i = 0; i < n; i++){
            if(!cities[i]){
                dfs(cities, i, isConnected);
                count++;
            }
        }
        return count;
    }

    void dfs(boolean[] cities, int cur, int[][] isConnected){
        cities[cur] = true;
        for(int i = 0; i < isConnected.length; i++){
            if(isConnected[cur][i] == 1 && cur != i && !cities[i]){
                dfs(cities, i, isConnected);
            }
        }
    }
}
```



#### 684 冗余连接（并查集）

树可以看成是一个连通且 无环 的 无向 图。

给定往一棵 n 个节点 (节点值 1～n) 的树中添加一条边后的图。添加的边的两个顶点包含在 1 到 n 中间，且这条附加的边不属于树中已存在的边。图的信息记录于长度为 n 的二维数组 edges ，edges[i] = [ai, bi] 表示图中在 ai 和 bi 之间存在一条边。

请找出一条可以删去的边，删除后可使得剩余部分是一个有着 n 个节点的树。如果有多个答案，则返回数组 edges 中最后出现的边。

看了题解做的：

- 如果两个顶点属于相同的连通分量，则说明在遍历到当前的边之前，这两个顶点之间已经连通，因此当前的边导致环出现，为附加的边，将当前的边作为答案返回。

```java
class Solution {
    public int[] findRedundantConnection(int[][] edges) {
        int[] parent = new int[edges.length + 1];
        for(int i = 0; i < parent.length; i++){
            parent[i] = i;
        }
        for(int[] edge: edges){
            if(find(parent, edge[0]) != find(parent, edge[1])){
                union(parent, edge[0], edge[1]);
            }
            else{
                return edge;
            }
        }
        return new int[0];
    }
    void union(int[] parent, int index1, int index2){
        parent[find(parent, index1)] = find(parent, index2);
    }
    int find(int[] parent, int index){
        while(parent[index] != index){
            index = parent[index];
        }
        return index;
    }
}
```



#### 713 乘积小于K的子数组（有点特别的滑动窗口）

给定一个正整数数组 `nums`和整数 `k` 。

请找出该数组内乘积小于 `k` 的连续的子数组的个数。

示例 1:

```
输入: nums = [10,5,2,6], k = 100
输出: 8
解释: 8个乘积小于100的子数组分别为: [10], [5], [2], [6], [10,5], [5,2], [2,6], [5,2,6]。
需要注意的是 [10,5,2] 并不是乘积小于100的子数组。
```

示例 2:

```
输入: nums = [1,2,3], k = 0
输出: 0
```


提示: 

1 <= nums.length <= 3 * 104
1 <= nums[i] <= 1000
0 <= k <= 10^6

一开始没想到滑动窗口，只写出了一个O(N^2)的解法

看了题解两次才弄懂。重点是res增加的时机，是while循环出来之后，这时从left乘到right的乘积是小于k的，说明这个范围以right为右端点的子数组都符合要求，所以加上right - left + 1，加一是因为长度为1的子数组也算。**总结一下就是right不断右移，每次都计算以right为右端点符合要求的有几个**

```java
class Solution {
    public int numSubarrayProductLessThanK(int[] nums, int k) {
        if(k <= 1) return 0;
        int res = 0;
        int left = 0, right = 0;
        int mul = 1; 
        while(right < nums.length){
            mul *= nums[right];     
            while(mul >= k){
                mul /= nums[left];
                left++;
            }
            res += (right - left + 1);
            right++;
        }
        return res;
    }
}
```



#### 797 所有可能的路径（DFS）

给你一个有 n 个节点的 有向无环图（DAG），请你找出所有从节点 0 到节点 n-1 的路径并输出（不要求按特定顺序）

 graph[i] 是一个从节点 i 可以访问的所有节点的列表（即从节点 i 到节点 graph[i][j]存在一条有向边）。



因为是有向无环图，所以不需要visited数组

```java
class Solution {
    public List<List<Integer>> allPathsSourceTarget(int[][] graph) {
        List<List<Integer>> res = new ArrayList<>();
        List<Integer> list = new ArrayList<>();
        dfs(res, list, graph, 0, graph.length - 1);
        return res;
    }
    void dfs(List<List<Integer>> res, List<Integer> list, int[][] graph, int start, int target){
        if(start == target){
            list.add(start);
            res.add(new ArrayList<>(list));
            list.remove(list.size() - 1);
            return;
        }
        int[] nodes = graph[start];
        list.add(start);
        for(int node : nodes){
            dfs(res, list, graph, node, target);
        }
        list.remove(list.size() - 1);
    }
}
```



#### 844 比较含退格的字符串（逆序遍历）

给定 s 和 t 两个字符串，当它们分别被输入到空白的文本编辑器后，如果两者相等，返回 true 。# 代表退格字符。

注意：如果对空文本输入退格字符，文本继续为空。

 

示例 1：

```
输入：s = "ab#c", t = "ad#c"
输出：true
解释：s 和 t 都会变成 "ac"。
```

示例 2：

```
输入：s = "ab##", t = "c#d#"
输出：true
解释：s 和 t 都会变成 ""。
```

示例 3：

```
输入：s = "a#c", t = "b"
输出：false
解释：s 会变成 "c"，但 t 仍然是 "b"。
```


提示：

+ 1 <= s.length, t.length <= 200
+ s 和 t 只含有小写字母以及字符 '#'


进阶：

+ 你可以用 O(n) 的时间复杂度和 O(1) 的空间复杂度解决该问题吗？

这道题其实不难，如果不用O(1)的空间复杂度的话。只要简单的模拟就行了，我用的string builder，也可以用stack。

```java
class Solution {
    public boolean backspaceCompare(String s, String t) {
        StringBuilder strbS = new StringBuilder();
        StringBuilder strbT = new StringBuilder();
        for(int i = 0; i < s.length(); i++){
            if(s.charAt(i) == '#'){
                if(strbS.length() > 0)
                    strbS.deleteCharAt(strbS.length() - 1);
            }
            else{
                strbS.append(s.charAt(i));
            }
        }
        for(int i = 0; i < t.length(); i++){
            if(t.charAt(i) == '#'){
                if(strbT.length() > 0)
                    strbT.deleteCharAt(strbT.length() - 1);
            }
            else{
                strbT.append(t.charAt(i));
            }
        }
        return strbS.toString().equals(strbT.toString());
    }
}
```

如果要用O(1)，就麻烦了，看了题解才知道是从后往前遍历字符串，遇到#就给skip变量加一，遇到其他字符就看看skip是否大于一，大于的话就skip--，看下一个字符，小于的话就break出来和另一个字符串比较

如果两个字符串break出来的时候对应的字符不等，或者一个有字符一个已经没有字符了，就是false。否则就继续，注意在最外层while出来后是return true，对应的是比如ab abc#这种

```java
class Solution {
    public boolean backspaceCompare(String s, String t) {
        int iter1 = s.length() - 1, iter2 = t.length() - 1;
        int skip1 = 0, skip2 = 0;
        while(iter1 >= 0 || iter2 >= 0){
            while(iter1 >= 0){
                if(s.charAt(iter1) == '#'){
                    skip1++;
                }
                else if(skip1 > 0){
                    skip1--;
                }
                else{
                    break;
                }
                iter1--;    
            }
            while(iter2 >= 0){
                if(t.charAt(iter2) == '#'){
                    skip2++;
                }
                else if(skip2 > 0){
                    skip2--;
                }
                else{
                    break;
                }
                iter2--;
            }
            if(iter1 >= 0 && iter2 >= 0){
                if(s.charAt(iter1) != t.charAt(iter2)){
                    return false;
                }
                else{
                    iter1--;
                    iter2--;
                }
            }
            else if(iter1 < 0 || iter2 < 0){
                return true;
            }
            else{
                return false;
            }
        }
        return true;
    }
}
```



#### 986 区间列表的交集（有点难的双指针）

给定两个由一些 闭区间 组成的列表，firstList 和 secondList ，其中 firstList[i] = [starti, endi] 而 secondList[j] = [startj, endj] 。每个区间列表都是成对 不相交 的，并且 已经排序 。

返回这 两个区间列表的交集 。

形式上，闭区间 [a, b]（其中 a <= b）表示实数 x 的集合，而 a <= x <= b 。

两个闭区间的 交集 是一组实数，要么为空集，要么为闭区间。例如，[1, 3] 和 [2, 4] 的交集为 [2, 3] 。

大致的思路是类似归并排序的做法，不断地取出右端点较小的区间，求出它可能的交集，然后移动指针到下一个区间，能这么做是因为右端点最小的区间只会有一个交集，如果有两个，它就不是最小的。所以不停地移除右端点最小的区间，就可以不断地得到交集

```java
class Solution {
    public int[][] intervalIntersection(int[][] firstList, int[][] secondList) {
        int iter1 = 0, iter2 = 0;
        List<int[]> list = new ArrayList<>();
        while(iter1 < firstList.length && iter2 < secondList.length){
            if(firstList[iter1][1] < secondList[iter2][1]){
                if(secondList[iter2][0] <= firstList[iter1][1]){
                    list.add(new int[]{Math.max(firstList[iter1][0], secondList[iter2][0]), firstList[iter1][1]});
                }
                iter1++;
            }
            else{
                if(firstList[iter1][0] <= secondList[iter2][1]){
                    list.add(new int[]{Math.max(firstList[iter1][0], secondList[iter2][0]), secondList[iter2][1]});
                }
                iter2++;
            }
        }
        return list.toArray(new int[0][0]);
    }
}
```

看了题解的写法感觉自己写得太傻了

```java
class Solution {
  public int[][] intervalIntersection(int[][] A, int[][] B) {
    List<int[]> ans = new ArrayList();
    int i = 0, j = 0;

    while (i < A.length && j < B.length) {
      // Let's check if A[i] intersects B[j].
      // lo - the startpoint of the intersection
      // hi - the endpoint of the intersection
      int lo = Math.max(A[i][0], B[j][0]);
      int hi = Math.min(A[i][1], B[j][1]);
      if (lo <= hi)
        ans.add(new int[]{lo, hi});

      // Remove the interval with the smallest endpoint
      if (A[i][1] < B[j][1])
        i++;
      else
        j++;
    }

    return ans.toArray(new int[ans.size()][]);
  }
}
```



#### 1063 有效子数组的数目（非严格单调递增栈）

给定一个整数数组 nums ，返回满足下面条件的 非空、连续 子数组的数目：

子数组 是数组的 连续 部分。
子数组最左边的元素不大于子数组中的其他元素 。


示例 1：

```
输入：nums = [1,4,2,5,3]
输出：11
解释：有 11 个有效子数组，分别是：[1],[4],[2],[5],[3],[1,4],[2,5],[1,4,2],[2,5,3],[1,4,2,5],[1,4,2,5,3] 。
```

示例 2：

```
输入：nums = [3,2,1]
输出：3
解释：有 3 个有效子数组，分别是：[3],[2],[1] 。
```

示例 3：

```
输入：nums = [2,2,2]
输出：6
解释：有 6 个有效子数组，分别为是：[2],[2],[2],[2,2],[2,2],[2,2,2] 。
```


提示：

+ 1 <= nums.length <= 5 * 104
+ 0 <= nums[i] <= 105



```java
class Solution {
    public int validSubarrays(int[] nums) {
        Stack<Integer> stack = new Stack<>();
        int res = 0;
        for(int i = 0; i < nums.length; i++){
            while(!stack.isEmpty() && nums[stack.peek()] > nums[i]){
                res += (i - stack.pop());
            }
            stack.push(i);
        }
        while(!stack.isEmpty()){
            res += (nums.length - stack.pop());
        }
        return res;
    }
}
```



#### 1091 二进制矩阵中的最短路径（BFS）

给你一个 n x n 的二进制矩阵 grid 中，返回矩阵中最短 畅通路径 的长度。如果不存在这样的路径，返回 -1 。

二进制矩阵中的 畅通路径 是一条从 左上角 单元格（即，(0, 0)）到 右下角 单元格（即，(n - 1, n - 1)）的路径，该路径同时满足下述要求：

路径途经的所有单元格都的值都是 0 。
路径中所有相邻的单元格应当在 8 个方向之一 上连通（即，相邻两单元之间彼此不同且共享一条边或者一个角）。
畅通路径的长度 是该路径途经的单元格总数。

```java
class Solution {
    int[][] directions = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}, {1, 1}, {-1, -1}, {-1, 1}, {1, -1}};

    public int shortestPathBinaryMatrix(int[][] grid) {
        Queue<int[]> queue = new LinkedList<>();
        int n = grid.length;
        if(n <= 0 || grid[0][0] == 1 || grid[n - 1][n - 1] == 1) return -1;
        queue.add(new int[]{0, 0});
        grid[0][0] = 1;
        int step = 1;
        while(!queue.isEmpty()){
            int size = queue.size();    
            while(size != 0){
                int[] position = queue.poll();
                if(position[0] == n - 1 && position[1] == n - 1) return step;
                addNeighbor(position[0], position[1], grid, queue);
                size--;
            }
            step++;
        }
        return -1;
    }
    void addNeighbor(int x, int y, int[][] grid, Queue<int[]> queue){ 
        for(int[] direction : directions){
            int curX = x + direction[0];
            int curY = y + direction[1];
            if(isValid(grid, curX, curY)){
                queue.add(new int[]{curX, curY});
                grid[curX][curY] = 1;
            }
        }
    }
    boolean isValid(int[][] grid, int x, int y){
        if(x < 0 || y < 0 || x >= grid.length || y >= grid[0].length || grid[x][y] == 1){
            return false;
        }
        return true;
    }
}
```



#### 1319 连通网络的操作次数（并查集）

用以太网线缆将 n 台计算机连接成一个网络，计算机的编号从 0 到 n-1。线缆用 connections 表示，其中 connections[i] = [a, b] 连接了计算机 a 和 b。

网络中的任何一台计算机都可以通过网络直接或者间接访问同一个网络中其他任意一台计算机。

给你这个计算机网络的初始布线 connections，你可以拔开任意两台直连计算机之间的线缆，并用它连接一对未直连的计算机。请你计算并返回使所有计算机都连通所需的最少操作次数。如果不可能，则返回 -1 。 

这道题看起来难，其实只需要知道有多少并查集就可以了，并查集的个数其实就是总的元素个数减去union的次数

```java
class Solution {
    public int makeConnected(int n, int[][] connections) {
        if(connections.length < n - 1) return -1;
        int[] parent = new int[n];
        for(int i = 0; i < n; i++){
            parent[i] = i;
        }
        int setCount = n;
        for(int[] connection : connections){
            if(find(parent, connection[0]) != find(parent, connection[1])){
                union(parent, connection[0], connection[1]);
                setCount--;
            }
        }
        return setCount - 1;
    }
    int find(int[] parent, int index){
        while(index != parent[index]){
            index = parent[index];
        }
        return index;
    }
    void union(int[] parent, int x, int y){
        parent[find(parent, x)] = find(parent, y);
    }
}
```

